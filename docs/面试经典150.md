# 数组

## T135 发糖果

**题目**

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**题解**

```java
/**
     * [5, 0, 1, 3, 4]
     * 两次遍历，分别从左遍历，如果 i < i + 1, 设为 1，否则设置为 +1
     * [1, 1, 2, 3, 4]
     * 从右边遍历，判断满足右边的规则需要的糖果
     * [2, 1, 1, 1, 1]
     * 最终为这两个的最大值
     * [2, 1, 2, 3, 4]
     * @param ratings
     * @return
     */
public int candyI(int[] ratings) {
    int n = ratings.length;
    int[] leftRule = new int[n];
    int candy = 0;

    // 遍历满足左规则的时候，需要的最少糖果
    for (int i = 0; i < n; i++) {
        // 当前孩子大于左边孩子，就增加1，否则就只有一颗糖果
        if (i > 0 && ratings[i] - ratings[i - 1] > 0) leftRule[i] = leftRule[i -1] + 1;
        else leftRule[i] = 1;
    }

    int rightRule = 1;
    // 遍历右规则
    for (int i = n - 1; i >= 0; i--) {
        if (i < n - 1 && ratings[i] > ratings[i + 1]) rightRule += 1;
        else rightRule = 1;

        candy += Math.max(leftRule[i], rightRule);
    }

    return candy;
}
```



## T42 接雨水

**题目描述**

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水.

![image-20240817115320232](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/image-20240817115320232.png)

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**题解**

```java 
// 左右双指针
public int trapI(int[] height) {
    int left = 0;
    int right = height.length-1;
    int leftMax = 0;
    int rightMax = 0;
    int water = 0;

    // 如果添加等于，则会造成一个柱子统计两次
    while (left < right) {
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);

        // 当前高度小于左边的最大高度，说明右边可以堵住
        if (height[left] < rightMax) {
            water += leftMax - height[left]; // 左边坝高 - 当前高度
            left++;
        } else {
            // 左边可以堵住
            water += rightMax - height[right]; // 右边坝高 - 当前高度
            right--;
        }
    }
    return water;
}
```

## T13 罗马数字转整数

**题目描述**

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

**题解**

```java
/**
     * 使用SwitchCase判断，当前大于前面的，就做减法
     * @param s
     * @return
     */
public int romanToIntII(String s) {
    int sum = 0;
    int preNum = getValue(s.charAt(0));
    for(int i = 1;i < s.length(); i ++) {
        int num = getValue(s.charAt(i));
        if(preNum < num) {
            sum -= preNum;
        } else {
            sum += preNum;
        }
        preNum = num;
    }
    sum += preNum;
    return sum;
}

private int getValue(char ch) {
    switch(ch) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}
```

## T12 整数转为罗马数字

**题目描述**

将整数转为罗马数字

**题解**

```java
public String intToRoman(int num) {
    String number = String.valueOf(num);
    Stack<String> resStack = new Stack<>();

    // 如何将数拆分为9,5,4,1
    // 3749: 1000 1000 1000 500 100 100 40 9
    int unit = 1;
    for (int i = number.length()-1; i >= 0; i--) {
        int single = (number.charAt(i) - '0');

        StringBuilder tempCode = new StringBuilder();

        // 按照9 5 4 1 对数字进行拆分并将此位罗马数字装进临时编码中
        while (single > 0) {
            if (single - 9 >= 0) {
                single -= 9;
                tempCode.append(getCode(9 * unit));
            }

            if (single - 5 >= 0) {
                single -= 5;
                tempCode.append(getCode(5 * unit));
            }

            if (single - 4 >= 0) {
                single -= 4;
                tempCode.append(getCode(4 * unit));
            }

            if (single - 1 >= 0) {
                single -= 1;
                tempCode.append(getCode(1 * unit));
            }
        }
        
        // 将此位的罗马数字压到栈中
        resStack.push(tempCode.toString());
        unit *= 10;

    }

    StringBuilder res = new StringBuilder();

    while(resStack.size() > 0) {
        res.append(resStack.pop());
    }

    return res.toString();

}

public String getCode(Integer number) {
    switch (number) {
        case 1: return "I";
        case 4: return "IV";
        case 5: return "V";
        case 9: return "IX";
        case 10: return "X";
        case 40: return "XL";
        case 50: return "L";
        case 90: return "XC";
        case 100: return "C";
        case 400: return "CD";
        case 500: return "D";
        case 900: return "CM";
        case 1000: return "M";
    }
    return "";

}
```



## T58 最后一个单词长度

**题目**

给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。

**示例 1：**

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为 5。
```

**题解**

```java
public int lengthOfLastWordI(String s) {

    int res = 0;
    // 倒序遍历
    for (int i = s.length() - 1; i >= 0; i--) {
        // 去掉尾部的空格
        if (s.charAt(i) == ' ' && res == 0) continue;
        if (s.charAt(i) == ' ') break;
        else res++;
    }

    return res;

}
```





## T14 公共最长前缀

**题目描述**

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**题解**

```java
public String longestCommonPrefix(String[] strs) {

        if (strs.length == 0) return "";
        if (strs.length == 1) return strs[0];

        StringBuilder prefix = new StringBuilder();

        for (int i = 0; i <= strs[0].length()-1; i++) {
            if (isSameChar(strs, i)) {
                prefix.append(strs[1].charAt(i));
            } else {
                break;
            }
        }
        return prefix.toString();

    }

    public boolean isSameChar(String[] strs, int index) {
        boolean flag = true;
        for (int i = 1; i < strs.length; i++) {
            // 下标边界判断
            if (index < strs[i].length() && strs[i].charAt(index) == strs[0].charAt(index)) continue;
            else {
                flag = false;
                break;
            }
        }
        return flag;
    }
```

## T151 反转字符串中的单词

**题目描述**

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**题解**

```java
public String reverseWords(String s) {
    String trimS = s.trim(); // 字符串瘦身
    String[] words = trimS.split(" "); // 空格拆分
    StringBuilder res = new StringBuilder(); 
    for (int i = words.length - 1; i >= 0; i--) {
        // 中间有连续空格就会造成有空串出现，需要判断
        if (!"".equals(words[i])) res.append(words[i]).append(" ");
    }
    return res.toString().trim();
}
```

## T6 Z字变换

**题目描述**

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

**题解**

```java
/**
* 首先确定V字的元素个数
* 其次是确定二维数组列数
* 垂直指针v，水平指针h
* 判断 当前总元素数 % V字元素数 < 行数 &&  当前总元素数 % V字元素数 ！= 0 V 向下; 反之v向上，h向右;
*
*/
public String convert(String s, int numRows) {
    if (numRows <= 1) return s;
    int elements = (2*numRows-2); // 一个V字的元素数
    int batch = s.length() / elements; // 有几组完整的V字
    int remainders = s.length() % elements; // 计算有多少列
    int col = batch * (numRows - 1);
    col += remainders <= numRows ? 1 : remainders - numRows + 1;

    char[][] map = new char[numRows][col];
    int v = 0; int h = 0;
    for (int i = 0; i < s.length(); i++) {
        map[v][h] = s.charAt(i);
        if ((i+1) % elements < numRows && (i+1) % elements != 0) { // 垂直指针往下走，水平不动
            v++;
        } else { // 垂直指针往上走，水平往右边走
            v--;
            h++;
        }
    }
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < col; j++) {
            if (map[i][j] != 0) {
                builder.append(map[i][j]);
            }
        }
    }
    return  builder.toString();

}



/**
* 使用curRow 和 boolean down 来控制方向
* 
*/
public String convert(String s, int numRows) {
    if (numRows <= 1) return s;
    // 首先确定总共有几行, 每一行作为一个StringBuffer加入入到集合中
    List<StringBuilder> rows = new ArrayList<StringBuilder>();
    for (int i = 0; i < Math.min(s.length(), numRows); i++) {
        rows.add(new StringBuilder());
    }

    int curRow = 0;
    boolean down = false;
    for (char c : s.toCharArray()) {
        rows.get(curRow).append(c);
        if (curRow == 0 || curRow == numRows - 1) { // 第一行和最后一行都需要改变方向
            down = !down;
        }
        curRow += down ? 1 : -1;
    }

    StringBuffer result = new StringBuffer();
    for (StringBuilder row : rows) {
        result.append(row);
    }
    return result.toString();

}

```

## T68 文本左右对齐

**题目描述**

给定一个单词数组 `words` 和一个长度 `maxWidth` ，重新排版单词，使其成为每行恰好有 `maxWidth` 个字符，且左右两端对齐的文本。

**示例 2:**

```
输入:words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
输出:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
```

**题解**

```java 
public List<String> fullJustify(String[] words, int maxWidth) {

        List<String> res = new ArrayList<>();

        int len = 0;
        List<String> rowWords = new ArrayList<>();
        for (int i = 0; i < words.length; i++) {
            if (len + words[i].length() <= maxWidth) {
                rowWords.add(words[i] + " ");
                len += words[i].length() + 1; // 每个单词要加一个空格
            } else {
                String rowString = getRowString(len, rowWords, maxWidth, false);
                res.add(rowString);
                len = 0;
                rowWords.clear();
                i--;
            }
        }
        // 对最后一行的处理
        res.add(getRowString(len, rowWords, maxWidth, true));
        return res;
    }


    public String getRowString(int len, List<String> rowWords, int maxWidth, boolean last) {
        // 此时单词应当是 This |is |an |
        len -= 1; // 用掉的长度为这么多
        int gaps = rowWords.size() - 1 == 0 ? 1 : rowWords.size() - 1; // 间隙
        int remainBlanks = maxWidth - len;
        StringBuilder blank = new StringBuilder();
        if (last) {
            // 最后一行左对齐
            for (int i = 0; i < remainBlanks; i++) {
                blank.append(" ");
            }
            rowWords.set(rowWords.size()-1, rowWords.get(rowWords.size()-1) + blank);
        } else {
            int blanks = remainBlanks / gaps; // 平均每个间隙插的空格数

            for (int j = 0; j < blanks; j++) {
                blank.append(" ");
            }
            int remainders = remainBlanks % gaps; // 剩多少个空格
            for (int j = 0; j < remainders; j++) {
                rowWords.set(j, rowWords.get(j) + " "); // 多出来的空格添加到左边
            }
            // 给每个单词添加空格
            for (int j = 0; j < gaps; j++) {
                rowWords.set(j, rowWords.get(j) + blank.toString());
            }
        }

        // 将单词拼接起来
        StringBuilder wordText = new StringBuilder();
        for (String word : rowWords) {
            wordText.append(word);
        }
        return wordText.substring(0, wordText.length() - 1);
    }
```

# 双指针

## T125 验证回文串

**题目描述**

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**题解**

```java
public boolean isPalindrome(String s) {
    // 去重，移出所有的非小写字母字符
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if ((c >= 'a' && c <= 'z') || (c + 32 >= 'a' && c + 32 <= 'z') || (c >= '0' && c <= '9')) {
            if ((c + 32 >= 'a' && c + 32 <= 'z')) {
                builder.append((char)(c + 32));
            } else {
                builder.append(c);
            }
        }
    }
    String trimString = builder.toString();
    int i = 0; int j = trimString.length() - 1;
    while (i < j) {
        if (trimString.charAt(i) == trimString.charAt(j)) {
            i++; j--;
        } else {
            return false;
        }
    }
    return true;
}

Character.isLetterOrDigit(). // 判断是否是数字或者是字母
```

## T392 判断子序列

**题目描述**

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**题解**

```java
/**
* 双指针
* /
public boolean isSubsequence(String s, String t) {

    int i = 0; int j = 0;
    while (i < s.length() && j < t.length()) {
        while (j < t.length() && s.charAt(i) != t.charAt(j)) {
            j++;
        }
        while (i < s.length() && j < t.length() && s.charAt(i) == t.charAt(j)) {
            i++; j++;
        }
    }
    return i >= s.length();
}


/**
     * 动态规划，f[i][j]表示从索引 i 开始 第 j 个小写字母出现的位置索引
     * @param s
     * @param t
     * @return
     */
public boolean isSubsequenceII(String s, String t) {
    int n = s.length(), m = t.length();

    int[][] f = new int[m + 1][26];
    for (int i = 0; i < 26; i++) {
        f[m][i] = m; // 如果出现m表示没有出现过该字母
    }

    for (int i = m - 1; i >= 0; i--) {
        for (int j = 0; j < 26; j++) {
            if (t.charAt(i) == j + 'a')
                f[i][j] = i; // 索引 i 开始后的 j 字母出现的第一个位置委 i
            else
                f[i][j] = f[i + 1][j];
        }
    }
    int add = 0;
    for (int i = 0; i < n; i++) {
        if (f[add][s.charAt(i) - 'a'] == m) {
            return false;
        }
        add = f[add][s.charAt(i) - 'a'] + 1;
    }
    return true;
}
```

## T167 两数之和II-输入为有序数组

**题目描述**

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**题解**

```java
/**
* 双指针
*
*/
public int[] twoSum(int[] numbers, int target) {
    int i = 0, j = numbers.length - 1;
    int[] res = new int[2];
    while (i < j) {
        if (numbers[i] + numbers[j] == target) {
            break;
        } else if (numbers[i] + numbers[j] > target) {
            j--;
        } else {
            i++;
        }
    }
    res[0] = i + 1;
    res[1] = j + 1;
    return res;
}

```

