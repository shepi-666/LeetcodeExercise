# 数组

## T135 发糖果

**题目**

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**题解**

```java
/**
     * [5, 0, 1, 3, 4]
     * 两次遍历，分别从左遍历，如果 i < i + 1, 设为 1，否则设置为 +1
     * [1, 1, 2, 3, 4]
     * 从右边遍历，判断满足右边的规则需要的糖果
     * [2, 1, 1, 1, 1]
     * 最终为这两个的最大值
     * [2, 1, 2, 3, 4]
     * @param ratings
     * @return
     */
public int candyI(int[] ratings) {
    int n = ratings.length;
    int[] leftRule = new int[n];
    int candy = 0;

    // 遍历满足左规则的时候，需要的最少糖果
    for (int i = 0; i < n; i++) {
        // 当前孩子大于左边孩子，就增加1，否则就只有一颗糖果
        if (i > 0 && ratings[i] - ratings[i - 1] > 0) leftRule[i] = leftRule[i -1] + 1;
        else leftRule[i] = 1;
    }

    int rightRule = 1;
    // 遍历右规则
    for (int i = n - 1; i >= 0; i--) {
        if (i < n - 1 && ratings[i] > ratings[i + 1]) rightRule += 1;
        else rightRule = 1;

        candy += Math.max(leftRule[i], rightRule);
    }

    return candy;
}
```



## T42 接雨水

**题目描述**

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水.

![image-20240817115320232](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/image-20240817115320232.png)

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**题解**

```java 
// 左右双指针
public int trapI(int[] height) {
    int left = 0;
    int right = height.length-1;
    int leftMax = 0;
    int rightMax = 0;
    int water = 0;

    // 如果添加等于，则会造成一个柱子统计两次
    while (left < right) {
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);

        // 当前高度小于左边的最大高度，说明右边可以堵住
        if (height[left] < rightMax) {
            water += leftMax - height[left]; // 左边坝高 - 当前高度
            left++;
        } else {
            // 左边可以堵住
            water += rightMax - height[right]; // 右边坝高 - 当前高度
            right--;
        }
    }
    return water;
}
```

## T13 罗马数字转整数

**题目描述**

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

**题解**

```java
/**
     * 使用SwitchCase判断，当前大于前面的，就做减法
     * @param s
     * @return
     */
public int romanToIntII(String s) {
    int sum = 0;
    int preNum = getValue(s.charAt(0));
    for(int i = 1;i < s.length(); i ++) {
        int num = getValue(s.charAt(i));
        if(preNum < num) {
            sum -= preNum;
        } else {
            sum += preNum;
        }
        preNum = num;
    }
    sum += preNum;
    return sum;
}

private int getValue(char ch) {
    switch(ch) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}
```

## T12 整数转为罗马数字

**题目描述**

将整数转为罗马数字

**题解**

```java
public String intToRoman(int num) {
    String number = String.valueOf(num);
    Stack<String> resStack = new Stack<>();

    // 如何将数拆分为9,5,4,1
    // 3749: 1000 1000 1000 500 100 100 40 9
    int unit = 1;
    for (int i = number.length()-1; i >= 0; i--) {
        int single = (number.charAt(i) - '0');

        StringBuilder tempCode = new StringBuilder();

        // 按照9 5 4 1 对数字进行拆分并将此位罗马数字装进临时编码中
        while (single > 0) {
            if (single - 9 >= 0) {
                single -= 9;
                tempCode.append(getCode(9 * unit));
            }

            if (single - 5 >= 0) {
                single -= 5;
                tempCode.append(getCode(5 * unit));
            }

            if (single - 4 >= 0) {
                single -= 4;
                tempCode.append(getCode(4 * unit));
            }

            if (single - 1 >= 0) {
                single -= 1;
                tempCode.append(getCode(1 * unit));
            }
        }
        
        // 将此位的罗马数字压到栈中
        resStack.push(tempCode.toString());
        unit *= 10;

    }

    StringBuilder res = new StringBuilder();

    while(resStack.size() > 0) {
        res.append(resStack.pop());
    }

    return res.toString();

}

public String getCode(Integer number) {
    switch (number) {
        case 1: return "I";
        case 4: return "IV";
        case 5: return "V";
        case 9: return "IX";
        case 10: return "X";
        case 40: return "XL";
        case 50: return "L";
        case 90: return "XC";
        case 100: return "C";
        case 400: return "CD";
        case 500: return "D";
        case 900: return "CM";
        case 1000: return "M";
    }
    return "";

}
```



## T58 最后一个单词长度

**题目**

给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。

**示例 1：**

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为 5。
```

**题解**

```java
public int lengthOfLastWordI(String s) {

    int res = 0;
    // 倒序遍历
    for (int i = s.length() - 1; i >= 0; i--) {
        // 去掉尾部的空格
        if (s.charAt(i) == ' ' && res == 0) continue;
        if (s.charAt(i) == ' ') break;
        else res++;
    }

    return res;

}
```





## T14 公共最长前缀

**题目描述**

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**题解**

```java
public String longestCommonPrefix(String[] strs) {

        if (strs.length == 0) return "";
        if (strs.length == 1) return strs[0];

        StringBuilder prefix = new StringBuilder();

        for (int i = 0; i <= strs[0].length()-1; i++) {
            if (isSameChar(strs, i)) {
                prefix.append(strs[1].charAt(i));
            } else {
                break;
            }
        }
        return prefix.toString();

    }

    public boolean isSameChar(String[] strs, int index) {
        boolean flag = true;
        for (int i = 1; i < strs.length; i++) {
            // 下标边界判断
            if (index < strs[i].length() && strs[i].charAt(index) == strs[0].charAt(index)) continue;
            else {
                flag = false;
                break;
            }
        }
        return flag;
    }
```

## T151 反转字符串中的单词

**题目描述**

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**题解**

```java
public String reverseWords(String s) {
    String trimS = s.trim(); // 字符串瘦身
    String[] words = trimS.split(" "); // 空格拆分
    StringBuilder res = new StringBuilder(); 
    for (int i = words.length - 1; i >= 0; i--) {
        // 中间有连续空格就会造成有空串出现，需要判断
        if (!"".equals(words[i])) res.append(words[i]).append(" ");
    }
    return res.toString().trim();
}
```

## T6 Z字变换

**题目描述**

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

**题解**

```java
/**
* 首先确定V字的元素个数
* 其次是确定二维数组列数
* 垂直指针v，水平指针h
* 判断 当前总元素数 % V字元素数 < 行数 &&  当前总元素数 % V字元素数 ！= 0 V 向下; 反之v向上，h向右;
*
*/
public String convert(String s, int numRows) {
    if (numRows <= 1) return s;
    int elements = (2*numRows-2); // 一个V字的元素数
    int batch = s.length() / elements; // 有几组完整的V字
    int remainders = s.length() % elements; // 计算有多少列
    int col = batch * (numRows - 1);
    col += remainders <= numRows ? 1 : remainders - numRows + 1;

    char[][] map = new char[numRows][col];
    int v = 0; int h = 0;
    for (int i = 0; i < s.length(); i++) {
        map[v][h] = s.charAt(i);
        if ((i+1) % elements < numRows && (i+1) % elements != 0) { // 垂直指针往下走，水平不动
            v++;
        } else { // 垂直指针往上走，水平往右边走
            v--;
            h++;
        }
    }
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < col; j++) {
            if (map[i][j] != 0) {
                builder.append(map[i][j]);
            }
        }
    }
    return  builder.toString();

}



/**
* 使用curRow 和 boolean down 来控制方向
* 
*/
public String convert(String s, int numRows) {
    if (numRows <= 1) return s;
    // 首先确定总共有几行, 每一行作为一个StringBuffer加入入到集合中
    List<StringBuilder> rows = new ArrayList<StringBuilder>();
    for (int i = 0; i < Math.min(s.length(), numRows); i++) {
        rows.add(new StringBuilder());
    }

    int curRow = 0;
    boolean down = false;
    for (char c : s.toCharArray()) {
        rows.get(curRow).append(c);
        if (curRow == 0 || curRow == numRows - 1) { // 第一行和最后一行都需要改变方向
            down = !down;
        }
        curRow += down ? 1 : -1;
    }

    StringBuffer result = new StringBuffer();
    for (StringBuilder row : rows) {
        result.append(row);
    }
    return result.toString();

}

```

## T68 文本左右对齐

**题目描述**

给定一个单词数组 `words` 和一个长度 `maxWidth` ，重新排版单词，使其成为每行恰好有 `maxWidth` 个字符，且左右两端对齐的文本。

**示例 2:**

```
输入:words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
输出:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
```

**题解**

```java 
public List<String> fullJustify(String[] words, int maxWidth) {

        List<String> res = new ArrayList<>();

        int len = 0;
        List<String> rowWords = new ArrayList<>();
        for (int i = 0; i < words.length; i++) {
            if (len + words[i].length() <= maxWidth) {
                rowWords.add(words[i] + " ");
                len += words[i].length() + 1; // 每个单词要加一个空格
            } else {
                String rowString = getRowString(len, rowWords, maxWidth, false);
                res.add(rowString);
                len = 0;
                rowWords.clear();
                i--;
            }
        }
        // 对最后一行的处理
        res.add(getRowString(len, rowWords, maxWidth, true));
        return res;
    }


    public String getRowString(int len, List<String> rowWords, int maxWidth, boolean last) {
        // 此时单词应当是 This |is |an |
        len -= 1; // 用掉的长度为这么多
        int gaps = rowWords.size() - 1 == 0 ? 1 : rowWords.size() - 1; // 间隙
        int remainBlanks = maxWidth - len;
        StringBuilder blank = new StringBuilder();
        if (last) {
            // 最后一行左对齐
            for (int i = 0; i < remainBlanks; i++) {
                blank.append(" ");
            }
            rowWords.set(rowWords.size()-1, rowWords.get(rowWords.size()-1) + blank);
        } else {
            int blanks = remainBlanks / gaps; // 平均每个间隙插的空格数

            for (int j = 0; j < blanks; j++) {
                blank.append(" ");
            }
            int remainders = remainBlanks % gaps; // 剩多少个空格
            for (int j = 0; j < remainders; j++) {
                rowWords.set(j, rowWords.get(j) + " "); // 多出来的空格添加到左边
            }
            // 给每个单词添加空格
            for (int j = 0; j < gaps; j++) {
                rowWords.set(j, rowWords.get(j) + blank.toString());
            }
        }

        // 将单词拼接起来
        StringBuilder wordText = new StringBuilder();
        for (String word : rowWords) {
            wordText.append(word);
        }
        return wordText.substring(0, wordText.length() - 1);
    }
```

# 双指针

## T125 验证回文串

**题目描述**

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**题解**

```java
public boolean isPalindrome(String s) {
    // 去重，移出所有的非小写字母字符
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if ((c >= 'a' && c <= 'z') || (c + 32 >= 'a' && c + 32 <= 'z') || (c >= '0' && c <= '9')) {
            if ((c + 32 >= 'a' && c + 32 <= 'z')) {
                builder.append((char)(c + 32));
            } else {
                builder.append(c);
            }
        }
    }
    String trimString = builder.toString();
    int i = 0; int j = trimString.length() - 1;
    while (i < j) {
        if (trimString.charAt(i) == trimString.charAt(j)) {
            i++; j--;
        } else {
            return false;
        }
    }
    return true;
}

Character.isLetterOrDigit(). // 判断是否是数字或者是字母
```

## T392 判断子序列

**题目描述**

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**题解**

```java
/**
* 双指针
* /
public boolean isSubsequence(String s, String t) {

    int i = 0; int j = 0;
    while (i < s.length() && j < t.length()) {
        while (j < t.length() && s.charAt(i) != t.charAt(j)) {
            j++;
        }
        while (i < s.length() && j < t.length() && s.charAt(i) == t.charAt(j)) {
            i++; j++;
        }
    }
    return i >= s.length();
}


/**
     * 动态规划，f[i][j]表示从索引 i 开始 第 j 个小写字母出现的位置索引
     * @param s
     * @param t
     * @return
     */
public boolean isSubsequenceII(String s, String t) {
    int n = s.length(), m = t.length();

    int[][] f = new int[m + 1][26];
    for (int i = 0; i < 26; i++) {
        f[m][i] = m; // 如果出现m表示没有出现过该字母
    }

    for (int i = m - 1; i >= 0; i--) {
        for (int j = 0; j < 26; j++) {
            if (t.charAt(i) == j + 'a')
                f[i][j] = i; // 索引 i 开始后的 j 字母出现的第一个位置委 i
            else
                f[i][j] = f[i + 1][j];
        }
    }
    int add = 0;
    for (int i = 0; i < n; i++) {
        if (f[add][s.charAt(i) - 'a'] == m) {
            return false;
        }
        add = f[add][s.charAt(i) - 'a'] + 1;
    }
    return true;
}
```

## T167 两数之和II-输入为有序数组

**题目描述**

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**题解**

```java
/**
* 双指针
*
*/
public int[] twoSum(int[] numbers, int target) {
    int i = 0, j = numbers.length - 1;
    int[] res = new int[2];
    while (i < j) {
        if (numbers[i] + numbers[j] == target) {
            break;
        } else if (numbers[i] + numbers[j] > target) {
            j--;
        } else {
            i++;
        }
    }
    res[0] = i + 1;
    res[1] = j + 1;
    return res;
}

```

## T15 三数之和

**题目描述**

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**题解**

```java
/**
     * beats 5%
     * 主要思路：
     * 1.排序
     * 2.定住一个数 i
     * 3.双指针i+1 length-1，往中间遍历，符合条件加入到Map中，去重
     * 4.返回
     * @param nums
     * @return
     */
public List<List<Integer>> threeSum(int[] nums) {

    List<List<Integer>> resList = new ArrayList<>();
    Map<String, List<Integer>> distinctMap = new HashMap<>();
    // 从左到右固定一个，然后双指针
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 2; i++) {
        int j = i + 1;
        int k = nums.length - 1;

        while (j < k) {
            if (nums[i] + nums[j] + nums[k] == 0) {
                List<Integer> res = new ArrayList<>();
                res.add(nums[i]);
                res.add(nums[j]);
                res.add(nums[k]);
                String key = nums[i] + "" + nums[j] + nums[k];
                distinctMap.putIfAbsent(key, res);
                j++;
                k--;
            } else if (nums[i] + nums[j] + nums[k] < 0) {
                j++;
            } else {
                k--;
            }
        }
    }
    // 对Map遍历
    for (Map.Entry<String, List<Integer>> res : distinctMap.entrySet()) {
        resList.add(res.getValue());
    }

    return resList;
}
```

可以优化的点：

* 如果第一个数就大于0，直接返回，`if nums[i] >0 break;`
* 如果最后一个数小于0，直接返回，`if nums[j] < 0 beak;`
* 去重操作怎么弄？就是如果下一个数还是等于当前的数，就直接跳过

# 滑动窗

## T209 长度最小的子数组

**题目描述**

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 

**子数组**

`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

> 一定要注意不能打乱元素的顺序

**题解**

```
/**
 * 根据题目要求应该是不能排序的、
 * 使用双指针，维护一个动态长度的窗口
 * @param target
 * @param nums
 * @return
 */
public int minSubArrayLenI(int target, int[] nums) {

    // 特殊情况
    if (nums.length  == 1) {
        return target <= nums[0] ? 1 : 0;
    }

    int curSum = nums[0];
    int minLen = Integer.MAX_VALUE;
    int i = 0; int j = 0;
    while (j < nums.length) {
        if (curSum >= target) {
            minLen = Math.min(minLen, j - i + 1);
            curSum -= nums[i++]; // 左边界内收
        } else {
            if (++j < nums.length) {
                curSum += nums[j];
            }
        }
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;

}
```

## T3 无重复字符串的最长字串

**题目描述**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串**的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**题解**

```java
/**
 * 使用双指针的方法
 * 主要思想：
 * 快慢指针，快指针添加元素，慢指针删除重复的元素
 * 元素保存在Hash表中，一定要记得将 i 和 重复元素 之间的所有元素删除
 * @param s
 * @return
 */
public int lengthOfLongestSubstring(String s) {
    int maxLen = 0;
    if (s.length() <= 1) return s.length();
    int i = 0; int j = 0;
    Map<Character ,Integer> dictMap = new HashMap<>();
    while (true) {

        while (j < s.length() &&  !dictMap.containsKey(s.charAt(j))) {
            dictMap.put(s.charAt(j), j++);
        }

        // 说明已经出现了重复的情况，或者是到头的情况
        maxLen = Math.max(maxLen, j - i);
        if (j == s.length()) return maxLen;

        // 清除掉HashMap中重复的元素
        int nextJump = dictMap.get(s.charAt(j));
        while (i <= nextJump) {
            dictMap.remove(s.charAt(i++));
        }
        dictMap.put(s.charAt(j), j++);
    }
}
```

## T30 串联所有的单词子串

**题目描述**

给定一个字符串 `s` 和一个字符串数组 `words`**。** `words` 中所有字符串 **长度相同**。

 `s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

**示例 1：**

```
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
```

**题解**

```java
public List<Integer> findSubstringI(String s, String[] words) {	
	List<Integer> res = new ArrayList<>();
    // 所有单词的个数
    int num = words.length;
    // 每个单词的长度（是相同的）
    int wordLen = words[0].length();
    // 字符串长度
    int stringLen = s.length();

    for (int i = 0; i < wordLen; i++) {
        // 遍历的长度超过了整个字符串的长度，退出循环
        if (i + num * wordLen > stringLen) {
            break;
        }
        // differ表示窗口中的单词频次和words中的单词频次之差
        Map<String, Integer> differ = new HashMap<>();
        // 初始化窗口，窗口长度为num * wordLen,依次计算窗口里每个切分的单词的频次
        for (int j = 0; j < num; j++) {
            String word = s.substring(i + j * wordLen, i + (j + 1) * wordLen);
            differ.put(word, differ.getOrDefault(word, 0) + 1);
        }
        // 遍历words中的word，对窗口里每个单词计算差值
        for (String word : words) {
            differ.put(word, differ.getOrDefault(word, 0) - 1);
            // 差值为0时，移除掉这个word
            if (differ.get(word) == 0) {
                differ.remove(word);
            }
        }
        // 开始滑动窗口
        for (int start = i; start < stringLen - num * wordLen + 1; start += wordLen) {
            if (start != i) {
                // 右边的单词滑进来
                String word = s.substring(start + (num - 1) * wordLen, start + num * wordLen);
                differ.put(word, differ.getOrDefault(word, 0) + 1);
                if (differ.get(word) == 0) {
                    differ.remove(word);
                }
                // 左边的单词滑出去
                word = s.substring(start - wordLen, start);
                differ.put(word, differ.getOrDefault(word, 0) - 1);
                if (differ.get(word) == 0) {
                    differ.remove(word);
                }
                word = s.substring(start - wordLen, start);
            }
            // 窗口匹配的单词数等于words中对应的单词数
            if (differ.isEmpty()) {
                res.add(start);
            }
        }
    }
    return res;
}
```

## T76 最小覆盖字串

**题目描述**

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

 **题解**

* 定义两个数组来记录词频
* 每当有新字符添加到母串的词频数组中，就判断是否涵盖
* 涵盖的话就`trim`字符串

```java
public String minWindow(String S, String t) {
    char[] s = S.toCharArray();
    int m = s.length;
    int ansLeft = -1;
    int ansRight = m;
    int left = 0;
    int[] cntS = new int[128]; // s 子串字母的出现次数
    int[] cntT = new int[128]; // t 中字母的出现次数
    for (char c : t.toCharArray()) {
        cntT[c]++;
    }
    for (int right = 0; right < m; right++) { // 移动子串右端点
        cntS[s[right]]++; // 右端点字母移入子串
        while (isCovered(cntS, cntT)) { // 涵盖
            if (right - left < ansRight - ansLeft) { // 找到更短的子串
                ansLeft = left; // 记录此时的左右端点
                ansRight = right;
            }
            cntS[s[left++]]--; // 左端点字母移出子串
        }
    }
    return ansLeft < 0 ? "" : S.substring(ansLeft, ansRight + 1);
}


/**
 * 如何判断涵盖呢？
 * 遍历，频次大于等于字串
 * @param cntS
 * @param cntT
 * @return
 */
private boolean isCovered(int[] cntS, int[] cntT) {
    for (int i = 'A'; i <= 'Z'; i++) {
        if (cntS[i] < cntT[i]) {
            return false;
        }
    }
    for (int i = 'a'; i <= 'z'; i++) {
        if (cntS[i] < cntT[i]) {
            return false;
        }
    }
    return true;
}
```

# 矩阵

## T36 有效的数独

**题目描述**

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

**解答**

* 先判断每一行是否满足规则
* 判断每一列是否满足规则
* 判断每个小方块是否满足规则

```java 
/**
     * 每行每列
     * @param board
     * @return
     */
public boolean isValidSudoku(char[][] board) {
    // 首先判断每行是否符合
    for (int i = 0; i < board.length; i++) {
        int[] isVisited = new int[10];
        for (int j = 0; j < board[i].length; j++) {
            if (board[i][j] != '.') {
                if (isVisited[board[i][j]- '0']  != 1) {
                    isVisited[board[i][j]- '0'] = 1;
                } else {
                    return false;
                }
            }
        }
    }

    // 判断每列是否符合
    for (int i = 0; i < board[0].length; i++) {
        int[] isVisited = new int[10];
        for (int j = 0; j < board.length; j++) {
            if (board[j][i] != '.') {
                if (isVisited[board[j][i] - '0'] != 1) {
                    isVisited[board[j][i] - '0'] = 1;
                } else {
                    return false;
                }
            }
        }
    }

    // 判断每个小方格是否符合
    for (int i = 2; i < board.length; i += 3) {
        for (int j = 2; j < board[0].length; j += 3) {
            int[] isVisited = new int[10];
            for (int k = i - 2; k <= i; k++) {
                for (int l = j - 2; l <= j; l++) {
                    if (board[k][l] != '.') {
                        if (isVisited[board[k][l] - '0'] != 1) {
                            isVisited[board[k][l] - '0'] = 1;
                        } else {
                            return false;
                        }
                    }
                }
            }
        }
    }

    return true;
}
```

## T54 螺旋矩阵

**题目描述**

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**思路**

* 四个方向`diretion`，`right->down->left->up`
* 四个边界，然后使用递归调用

```java
public List<Integer> spiralOrder(int[][] matrix) {


    // 0 左 1 下 2 右 3 上
    int direction = 0;
    List<Integer> res = new ArrayList<>();
    // 边界
    int[] border = new int[4];
    border[0] = matrix[0].length-1; // 右边界
    border[1] = matrix.length-1; // 下边界
    border[2] = 0; // 上边界
    border[3] = 0; // 左边界

    rotateMatrix(matrix, direction, res, border);
    return res;
}

private void rotateMatrix(int[][] matrix, int direction, List<Integer> res, int[] border) {
    if (res.size() == matrix.length * matrix[0].length) return;
    switch (direction) {
        case 0:
            // 从左到右,固定上边界，上边界减1
            for (int k = border[3]; k <= border[0]; k++) {
                res.add(matrix[border[2]][k]);
            }
            // 上边界加1
            border[2]++;
            // 向下打印
            rotateMatrix(matrix, 1, res, border);
            break;
        case 1:
            // 从上到下,右边界固定，右边界减1
            for (int k = border[2]; k <= border[1]; k++) {
                res.add(matrix[k][border[0]]);
            }
            border[0]--;
            // 向左打印
            rotateMatrix(matrix, 2, res, border);
            break;
        case 2:
            // 从右往左打印，固定下边界，下边界减1
            for (int i = border[0]; i >= border[3]; i--) {
                res.add(matrix[border[1]][i]);
            }
            border[1]--;
            rotateMatrix(matrix, 3, res, border);
            break;
        case 3:
            for (int i = border[1]; i >= border[2]; i--) {
                res.add(matrix[i][border[3]]);
            }
            border[3]++;
            rotateMatrix(matrix, 0, res, border);
    }
}
```

## T48 旋转图像

**题目描述**

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**题解**

* 从右下角开始读取元素，一圈到数组中，每一圈有4$N$个元素
* 从数组开始读取元素，写到原来的矩阵中

![image-20240914175918447](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/image-20240914175918447.png)

观察翻转前后的图，我们可以看出，主要是进行了以下的操作：

* 将矩阵转置

* 交换每一行的首尾元素

```java
public void rotateI(int[][] matrix) {
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < i; j++) {
            // 交换matrix[i][j]和matrix[j][i]
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // 对每一行进行反转
    for (int i = 0; i < matrix.length; i++) {
        int l = 0; int r = matrix[i].length - 1;
        while (l < r) {
            int temp = matrix[i][l];
            matrix[i][l] = matrix[i][r];
            matrix[i][r] = temp;

            l++;
            r--;
        }
    }

    System.out.println("=========after===========");
    for (int i = 0; i < matrix.length; i++) {
        System.out.println(Arrays.toString(matrix[i]));
    }
}
```

## T73 矩阵置零

**题目描述**

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

**题解**

```java
/**
     * 实现思路：先遍历一遍，将行和列分别存储在两个set中
     * 再遍历一遍，如果当前坐标在set中，就置为0
     * @param matrix
     */
public void setZeroes(int[][] matrix) {
    Set<Integer> rowSet = new HashSet<>();
    Set<Integer> colSet = new HashSet<>();

    // 将 0 元素的行列存储到对应的 set 中
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) {
            if (matrix[i][j] == 0) {
                rowSet.add(i);
                colSet.add(j);
            }
        }
    }

    // set 中的行或者列都置为 0
    for (int i = 0; i < matrix.length; i++) {
        if (rowSet.contains(i)) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = 0;
            }
        } else {
            for (int j = 0; j < matrix[i].length; j++) {
                if (colSet.contains(j)) {
                    matrix[i][j] = 0;
                }
            }
        }
    }


    System.out.println("=========transformed matrix==========");
    for (int i = 0; i < matrix.length; i++) {
        System.out.println(Arrays.toString(matrix[i]));
    }
}
```

**优化方法**

使用空间为$o(1)$实现代码

* 第一行作为标记行，记录出现0的列
* 第一列作为标记列，记录出现0的行
* 额外两个变量，分别记录第一列和第一行是否为0
* 将含0的行和含0的列置为0
* 对第一行进行处理

## T289 生命游戏

**题目描述**

给定一个包含 `m × n` 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： `1` 即为 **活细胞** （live），或 `0` 即为 **死细胞** （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 `m x n` 网格面板 `board` 的当前状态，返回下一个状态。

**题解**

```java
/**
 * 1.定义一个统计周围活细胞的方法
 * 2.根据条件确定该细胞是否存活
 * @param board
 */
public void gameOfLife(int[][] board) {

    int[][] aliveCells = new int[board.length][board[0].length];

    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[i].length; j++) {
            // 当前细胞死活
            int counts = countAliveCells(i, j, board);
            if (board[i][j] == 1) {
                if (counts < 2) {
                    aliveCells[i][j] = 0;
                } else if (counts <= 3) {
                    aliveCells[i][j] = 1;
                } else {
                    aliveCells[i][j] = 0;
                }
            } else {
                // 当前细胞死了
                if (counts == 3) {
                    aliveCells[i][j] = 1;
                } else {
                    aliveCells[i][j] = 0;
                }
            }
        }
    }


    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            board[i][j] = aliveCells[i][j];
        }
    }


    System.out.println("===========next status============");
    for (int[] rows : aliveCells) {
        System.out.println(Arrays.toString(rows));;
    }

}

private int countAliveCells(int i, int j, int[][] board) {
    int beginRow = Math.max(i - 1, 0);
    int endRow = Math.min(i + 1, board.length - 1);
    int beginCol = Math.max(j - 1, 0);
    int endCol = Math.min(j + 1, board[0].length - 1);

    int count = 0;
    for (int k = beginRow; k <= endRow; k++) {
        for (int l = beginCol; l <= endCol; l++) {
            if (board[k][l] == 1 && (k != i || l != j)) {
                count++;
            }
        }
    }

    return count;
}
```

**优化思路**

* 细胞具体可以分为4种状态
  * 当前死，下一秒死：`00`
  * 当前死，下一秒活：`10`
  * 当前活，下一秒死：`01`
  * 当前活，下一秒活：`11`

* 获取当前状态的方法：`board[i][j] & 1`
* 获取下一秒状态的方法：`board[i][j] >> 1`

# 哈希表

## T383 赎金信

**题目描述**

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**题解**

```java
/**
 * 将 magazine中的字符和出现频次统计在HashMap中
 * 遍历 ransomNote，如果出现，就减1
 * @param ransomNote
 * @param magazine
 * @return
 */
public boolean canConstruct(String ransomNote, String magazine) {
    Map<Character, Integer> charMap = new HashMap<>();
    // 将magazine中的字符统计在HashMap
    for (char c : magazine.toCharArray()) {
        if (charMap.containsKey(c)) {
            charMap.put(c, charMap.get(c) + 1);
        } else {
            charMap.put(c, 1);
        }
    }

    for (char c : ransomNote.toCharArray()) {
        if (!charMap.containsKey(c)) {
            return false;
        } else {
            int counts = charMap.get(c);
            if (counts == 1) {
                charMap.remove(c, counts);
            } else {
                charMap.put(c, counts - 1);
            }
        }
    }
    return true;
}
```

**优化方法**

题目中给出，两者全部由小写字母给出，可以使用1个定长数组进行统计`magazine`数组出现的字符。如果`magazine`包含`ransomNote`就可以。

具体来说就是遍历`ransomNote`的时候对`magazine`统计数组操作

**优化方法二**

`int[] res`记录当前字符在数组中出现的位置的下一位的坐标，使用`indexOf`确定是否含有当前字符

## T205 同构字符串

**题目描述**

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**题解**

```java
/**
 * 分别将 s对t的映射和t对s的映射存储到两个Map中
 * @param s
 * @param t
 * @return
 */
public boolean isIsomorphic(String s, String t) {
    Map<Character, Character> s2t = new HashMap<>();
    Map<Character, Character> t2s = new HashMap<>();

    for (int i = 0; i < s.length(); i++) {
        char x = s.charAt(i);
        char y = t.charAt(i);
        if (s2t.containsKey(x) && s2t.get(x) != y || t2s.containsKey(y) && t2s.get(y) != x) {
            return false;
        }
        s2t.put(x, y);
        t2s.put(y, x);
    }
    return true;
}
```

## T290 单词规律

**题目描述**

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

```
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
```

**题解**

> 和T205相同的做法

```java
/**
 * 将字符串拆分为数组
 * @param pattern
 * @param s
 * @return
 */
public boolean wordPattern(String pattern, String s) {
    String[] array = s.split(" ");
    char[] chars = pattern.toCharArray();
    if (chars.length != array.length) return false;
    Map<Character, String> c2s =  new HashMap<>();
    Map<String, Character> s2c = new HashMap<>();
    for (int i = 0; i < array.length; i++) {
        if (c2s.containsKey(chars[i]) && !c2s.get(chars[i]).equals(array[i]) ||
                s2c.containsKey(array[i]) && !s2c.get(array[i]).equals(chars[i])) {
            return false;
        }
        c2s.put(chars[i], array[i]);
        s2c.put(array[i], chars[i]);
    }
    return true;

}
```

## T242 有效的字母异位词

**题目描述**

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的 字母异位词

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**题解**

* 字符串仅仅包含小写字符，可以使用两个数组统计词频
* 判断词频是否相同

```java
public boolean isAnagram(String s, String t) {
    int[] codeBook = new int[26];
    Arrays.fill(codeBook, 0);
    for (char c : s.toCharArray()) {
        codeBook[c - 'a'] ++;
    }
    for (char c : t.toCharArray()) {
        if (codeBook[c - 'a'] == 0) {
            return false;
        }
        codeBook[c - 'a']-- ;
    }

    // 检查codeBook是否为0
    for (int i : codeBook) {
        if (i != 0) {
            return false;
        }
    }
    return true;
}
```

## T49 字母异位词分组

**题目描述**

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**思路**

* `Map<String, Integer> codeBook`用来比较词频，其中`String`表示压缩编码，而`Integer`表示结果集中的索引
* `List<List<String>>`存放返回结果
* 遍历字符串数组，如果词频数组相同，就根据词频数组的索引加入到相应索引中
  * 否则添加到新的数组中，并加入到词频`Map`中

**题解**

```java
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> resList = new ArrayList<>();
    Map<String, Integer> codeBook = new HashMap<>();

    for (String str : strs) {
        String compressedCode = getCharCounts(str);
        if (codeBook.containsKey(compressedCode)) {
            int i = codeBook.get(compressedCode);
            resList.get(i).add(str);
        } else {
            List<String> strList = new ArrayList<>();
            strList.add(str);
            resList.add(strList);
            int i = resList.lastIndexOf(strList);
            codeBook.put(compressedCode, i);
        }
    }

    return resList;
}


/**
 * 统计单词每个字符出现的词频，并进行压缩返回
 * @param str
 * @return
 */
private String getCharCounts(String str) {

    int[] array = new int[26]; // 记录词频的数组
    Arrays.fill(array, 0);

    for (char c : str.toCharArray()) {
        array[c - 'a']++;
    }

    // 将词频转换为压缩字符串
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < array.length; i++) {
        if (array[i] != 0) {
            sb.append(i + 'a').append(array[i]);
        }
    }
    return sb.toString();
}
```

## T1 两数之和

**题目描述**

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

**题解**

* 如果余数`target - nums[i]`匹配失败，才会让`nums[i]`入库，防止和自己重复匹配

```java
/**
 * map存放和target - nums[i]匹配失败的数字
 * @param nums
 * @param target
 * @return
 */
public int[] twoSum(int[] nums, int target) {
    // 如果出现重复的数字，那么只会重复一次，并且答案就是重复的两个数字
    Map<Integer, Integer> map = new HashMap<>();
    int[] res = new int[2];
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(target - nums[i])) {
            res[0] = i;
            res[1] = map.get(target - nums[i]);
            return  res;
        } else {
            map.put(nums[i], i);
        }
    }
    return null;
}
```

## T202 快乐数

**题目描述**

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**思路**

* 按位取平方和，判断是否为1
* 平方和为1直接返回
* 平方和不为1存到`set`中
* 如果和存在，则返回`false`

```java
public boolean isHappy(int n) {
    Set<Integer> sumSet = new HashSet<>();
    while (true) {
        n = squareSum(n);
        if (n == 1) return true;
        else {
            if (sumSet.contains(n)) return false;
            else sumSet.add(n);
        }
    }
}

private int squareSum(int n) {
    int res = 0;
    String numStr = String.valueOf(n);
    for (char c : numStr.toCharArray()) {
        res += Math.pow(c - '0', 2.0);
    }
    return res;
}
```

**优化**

> 注意到，平方和作为一个链表中的一个节点出现，如果出现死循环，一定是链表中出现了环，就变成如何判断链表中是否出现环了

因此可以使用快慢指针，快指针一次操作两次，慢指针一次操作1次。判断相遇的时候是否为节点1

```java
/**
* 使用快慢指针实现
* @param n
* @return
*/
public boolean isHappyI(int n) {
    int slow = squareSum(n);
    int fast = squareSum(slow);
    while (slow != fast) {
        slow = squareSum(slow);
        fast = squareSum(fast);
        fast = squareSum(fast);
    }
    return slow == 1;
}
```

## T219 存在重复元素II

**题目描述**

给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

**思路**

* 定义一个`Map<Integer, Integer>`存储数字和坐标
* 如果当前数字`nums[i]`不存在，则直接入库
* 如果存在，则比较`map`中坐标`j`和当前坐标`i`的距离是否大于`k`，是的话直接返回`true`
* 距离小于`k`则不入库

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(nums[i])) {
            if (i - map.get(nums[i]) <= k) {
                return true;
            }
        }
        map.put(nums[i], i);

    }
    return false;
}
```

## T128 最长连续序列

**题目描述**

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**思路**

* 首先将数组去重

* 将数组排序
* 双指针判断是否连续，如果连续则当前长度`curLen++`
* 不连续当前长度置零`curLen = 0`
* 判断当前长度和最大长度的大小`maxLen = Math.max(curLen, maxLen)`

```java
public int longestConsecutive(int[] nums) {
    int maxLen = 1;
    if (nums.length <= 1) return nums.length;
    // nums中可能有重复的，需要去重操作
    Set<Integer> numSet = new HashSet<>();
    for (int i : nums) {
        numSet.add(i);
    }
    List<Integer> distinctList = new ArrayList<>(numSet);
    int[] distinctNums = new int[distinctList.size()];
    for (int i = 0; i < distinctNums.length; i++) {
        distinctNums[i] = distinctList.get(i);
    }
    Arrays.sort(distinctNums);

    int i = 0; int j = 1;
    while (j < distinctNums.length) {
        while (j < distinctNums.length && distinctNums[j] - distinctNums[j - 1] == 1) {
            j++;
        }
        maxLen = Math.max(j - i, maxLen);
        i = j++; // 新序列的第一个位置和第二个位置
    }


    return maxLen;


}
```

**优化思路**

> 题目给出的是使用$O(n)$的计算复杂度，所以就不能使用排序的方式了。

* 考虑将所有的元素存储到一个`Set<Integer> numSet`集合中
* 如果集合中不存在`num[i]-1`元素，就以当前元素为序列起始点
* 循环判断集合中是否存在`num[i] + 1`元素
* 记录最长的长度

```java
/**
 * 使用 o(n)的算法优化
 * @param nums
 * @return
 */
public int longestConsecutiveI(int[] nums) {


    if (nums.length <= 1) return nums.length;
    Set<Integer> numSet = new HashSet<>();
    for (int j : nums) {
        numSet.add(j);
    }
    int maxLen = 1;

    for (int num : nums) {

        // 当前值为序列头
        if (!numSet.contains(num - 1)) {
            int nextNum = num + 1;
            int curLen = 1;
            // 下一个值能够续上
            while (numSet.contains(nextNum)) {
                curLen++;
                nextNum++;
            }
            maxLen = Math.max(curLen, maxLen);
        }
    }
    return maxLen;
}
```

# 区间

## T228 汇总区间

**题目描述**

给定一个  **无重复元素** 的 **有序** 整数数组 `nums` 。

返回 ***恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表* 。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。

列表中的每个区间范围 `[a,b]` 应该按如下格式输出：

- `"a->b"` ，如果 `a != b`
- `"a"` ，如果 `a == b`

**思路**

重点就是，寻找连续区间的端点。

* 双指针，遍历数组

**题解**

```java
public List<String> summaryRanges(int[] nums) {
    List<String> res = new ArrayList<>();

    if (nums.length == 0) return res;
    if (nums.length == 1) {
        res.add(String.valueOf(nums[0]));
        return res;
    }

    int i = 0; int j = 1;
    while (true) {
        while (j < nums.length && nums[j] - nums[j - 1] == 1) j++;
        // 此时 j 处于下一个的左端点，i 处于上一个的左端点
        if (i == j - 1) {
            res.add(String.valueOf(nums[i]));
        } else {
            // 将区间放入到res中
            StringBuilder sb = new StringBuilder();
            sb.append(nums[i]).append("->").append(nums[j - 1]);
            res.add(sb.toString());
        }
        if (j == nums.length) break;
        // i跳到下一个区间的左端点，j右移一位
        i = j++;
    }


    return res;

}
```

## T56 合并区间

**题目描述**

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**思路分析**

> 什么样的才算是重叠区间？
>
> * 区间A的右端点大于等于区间B的左端点 并且 区间A的左端点小于等于区间B的右端点

* 拿到一个区间，遍历碰撞临时区间结果`tempList`中的区间
* 产生碰撞，保存碰撞后的左右指针，然后删除被碰撞的区间
* 将碰撞后产生的区间添加到临时区间集合中

> `for`循环遍历删除会产生`CME`的异常，使用迭代器迭代。

**我的题解**

```Java
public int[][] merge(int[][] intervals) {
    List<List<Integer>> tempList = new ArrayList<>();

    if (intervals.length <= 1) return intervals;

    for (int[] interval : intervals) {
        mergeInterval(interval, tempList);
    }

    int[][] res = new int[tempList.size()][2];
    for (int i = 0; i < res.length; i++) {
        for (int j = 0; j < res[i].length; j++) {
            res[i][j] = tempList.get(i).get(j);
            System.out.print(res[i][j] + "\t");
        }
        System.out.println();
    }
    return res;
}

/**
 * 将当前区间和区间列表中的区间进行合并
 * @param interval
 * @param tempList
 */
private void mergeInterval(int[] interval, List<List<Integer>> tempList) {

    // 当前区间无法和区间列表合并
    List<Integer> newInterval = new ArrayList<Integer>();
    int lIndex = interval[0];
    int rIndex = interval[1];

    Iterator<List<Integer>> iterator = tempList.iterator();
    while (iterator.hasNext()){
        List<Integer> tempInterval = iterator.next();
        // 可以合并区间的情况
        // 右A >= 左B && 左A <= 右B
        int leftA = lIndex;
        int rightA = rIndex; // 碰撞之后的指针
        int leftB = tempInterval.get(0);
        int rightB = tempInterval.get(1);
        if (rightA >= leftB && leftA <= rightB || rightB >= leftA && leftB <= rightA) {
            lIndex = Math.min(leftA, leftB);
            rIndex = Math.max(rightA, rightB);
            iterator.remove();
        }
    }
    newInterval.add(lIndex);
    newInterval.add(rIndex);


    tempList.add(newInterval);
}
```

**优化思路**

* 首先将区间按照左端点排序
* 可以合并的情况：当前区间的左端点小于前一个区间的右端点

```java
public int[][] mergeI(int[][] intervals) {

    if (intervals.length <= 1) return intervals;

    Arrays.sort(intervals, new Comparator<int[]>() {
        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[0] - o2[0]; // 按照左端点排序
        }
    });

    int count = 0; // 表示合并后区间的数量
    int[] pre = intervals[0]; // 假定为标定区间，用于比较
    for (int i = 1; i < intervals.length; i++) {
        int[] cur = intervals[i];
        if (cur[0] <= pre[1]) {
            // 可以进行区间合并，确定右端点，左端点已经确定
            int r = Math.max(cur[1], pre[1]);
            pre = new int[]{pre[0], r};
        } else {
            // 不能合并，将合并区间放入到原数组count 位置
            intervals[count++] = pre;
            pre = cur;
        }
    }

    // 将最后合并的区间记录下来
    intervals[count++] = pre;

    return Arrays.copyOfRange(intervals, 0, count);

}
```

## T57 插入区间

**题目描述**

给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表 `intervals`，其中 `intervals[i] = [starti, endi]` 表示第 `i` 个区间的开始和结束，并且 `intervals` 按照 `starti` 升序排列。同样给定一个区间 `newInterval = [start, end]` 表示另一个区间的开始和结束。

在 `intervals` 中插入区间 `newInterval`，使得 `intervals` 依然按照 `starti` 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。

返回插入之后的 `intervals`。

**注意** 你不需要原地修改 `intervals`。你可以创建一个新数组然后返回它。

**示例 1：**

```
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
```

**我的思路**

* 和T56相似，先把目标区间插入到`interval`数组中，然后排序
* 之后的思路就和之前的相同

**我的代码**

```java
public int[][] insert(int[][] intervals, int[] newInterval) {
    int[][] totalIntervals = Arrays.copyOf(intervals, intervals.length + 1);
    totalIntervals[totalIntervals.length - 1] = newInterval;

    // 排序
    Arrays.sort(totalIntervals, new Comparator<int[]>() {
        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[0] - o2[0];
        }
    });

    int[] pre = totalIntervals[0];
    int count = 0;
    for (int i = 1; i < totalIntervals.length; i++) {
        int[] cur = totalIntervals[i];
        if (cur[0] <= pre[1]) {
            int r = Math.max(cur[1], pre[1]);
            pre = new int[]{pre[0], r};
        } else {
            totalIntervals[count++] = pre;
            pre = cur;
        }
    }
    totalIntervals[count++] = pre;
    return Arrays.copyOfRange(totalIntervals, 0, count);
}
```

**优化思路**

朴素的模拟思想，原区间已经排好序了，拿着目标区间和每个区间进行比较。

* 需要有一个标记`isPlaced`判断目标区间是否放入的结果集中

* 如果目标区间在当前区间左边，`cur[0] > right`，直接将**目标区间**和**当前区间**放入到结果集合`List<int[]>`
* 如果目标表区间在当前区间右边，`cur[1] <  left`，将**当前区间**放入到结果集合中
* 如果发生了碰撞，记录碰撞之后的区间边界
  * `left = Math.min(left, cur[0])`
  * `right = Math.max(right, cur[1])`
* 最后如果没有被放入的话，将碰撞之后的区间放入`new int[]{left, right}`

**优化代码**

```java
public int[][] insertI(int[][] intervals, int[] newInterval) {
    List<int[]> list = new ArrayList<>(); // 结果集
    // 记录插入区间的左右坐标
    int left = newInterval[0];
    int right = newInterval[1];
    boolean placed = false; // 是否插入的标记
    for(int[] interval:intervals){ // 遍历每个区间
        if(interval[0] > right){
            // 当前区间在目标区间的右侧，并且没有插入，说明新区间和所有的都没有交集，直接放入
            if(!placed){
                list.add(new int[]{left,right}); // 放入插入区间
                placed=true;
            }
            list.add(interval); // 放入当前区间
        }else if(interval[1] < left){ // 当前区间在目标区间的左侧
            list.add(interval); // 放入当前区间
        }else{
            // 有重合的情况，记录碰撞之后的区间
            left = Math.min(left, interval[0]);
            right = Math.max(right, interval[1]);
        }
    }
    if(!placed){ // 没有放入
        list.add(new int[]{left,right});
    }

    // 将列表转换为数组
    int[][] ans = new int[list.size()][];
    for(int k = 0; k<list.size();k++){
        ans[k] = list.get(k);
    }
    return ans;
}
```

## T452 用最少数量的箭引爆气球

**题目描述**

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

**示例 1：**

```
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
```

**我的思路**

* 首先将区间根据左端点排序：`[1, 6] [2, 8], [7, 12] [10, 16]`
* 如果区间相交了`if cur[0] < pre[1]`，计算出相交区间`{cur[0], pre[1]}`
* 相交区间接着比较`[2, 6] [7, 12]`，发现不相交，`count++`，`pre = cur`
* 最后一支箭命中相交区间`count++`

```java
public int findMinArrowShots(int[][] points) {
    if (points.length <= 1) return points.length;

    int count = 0; // 计算需要的键数
    // 先将气球排序好
    Arrays.sort(points, Comparator.comparingInt(o -> o[0]));

    int[] pre = points[0];
    for (int i = 1; i < points.length; i++) {
        // 如果没有产生碰撞，需要一支箭
        int[] cur = points[i];
        if (pre[1] < cur[0]) {
            count++;
            pre = cur;
        } else {
            // 产生碰撞，计算碰撞区间
            int l = cur[0];
            int r = Math.min(cur[1], pre[1]);
            // 将相交区间赋值给pre
            pre = new int[]{l, r};
        }
    }
    // 最后一支箭 pre
    count++;
    return count;
}
```

# 栈

## T20 有效的括号

**题目描述**

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**我的思路**

* 使用栈存储括号，如果发生配对，就弹出
* 最后判断一下栈是否为空

```Java
public boolean isValid(String s) {

    Stack<Character> stack = new Stack<>();
    for (char c : s.toCharArray()) {
        // 注意括号顺序，当前字符要比栈中的大
        if (stack.size() != 0 && c - stack.peek() <= 2 && c - stack.peek() > 0) {
            stack.pop();
        } else {
            stack.push(c);
        }
    }
    return stack.size() == 0;
}
```

## T71 简化路径

**题目描述**

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为 **更加简洁的规范路径**。

在 Unix 风格的文件系统中规则如下：

- 一个点 `'.'` 表示当前目录本身。
- 此外，两个点 `'..'` 表示将目录切换到上一级（指向父目录）。
- 任意多个连续的斜杠（即，`'//'` 或 `'///'`）都被视为单个斜杠 `'/'`。
- 任何其他格式的点（例如，`'...'` 或 `'....'`）均被视为有效的文件/目录名称。

返回的 **简化路径** 必须遵循下述格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。

返回简化后得到的 **规范路径** 。

**我的思路**

* 使用`split('/')`将路径字符串分割为字符数组
* 将字符串数组中的字符串压入双端队列中
  * `.`：不做任何处理
  * `..`：弹出
  * `others`：压入栈中

> 双端队列接口`Deque<>`，接口的实现类：`ArrayQueue`和`LinkedList`
>
> * `addLast()`：队列尾部添加元素
> * `pushFirst()`：队列首部添加元素

```Java
String[] directories = path.split("/");
    Deque<String> resQueue = new ArrayDeque<>();


    for (String directory : directories) {
        if ("..".equals(directory)) {
            // 弹出最后一个，表示返回上一层
            if (resQueue.size() != 0) resQueue.pollLast();

        } else if (!".".equals(directory) && !"".equals(directory)) {
            resQueue.addLast(directory);
        }
    }
    if (resQueue.size() == 0) return "/";
    StringBuilder newPath = new StringBuilder();
    while (resQueue.size() != 0) {
        newPath.append("/").append(resQueue.pollFirst());
    }
    return newPath.toString();
}
```

## T155 最小栈

**题目描述**

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**我的思路**

==常数时间内检索到栈中最小元素==

两个栈实现：

* 数据栈：用来存储数据
* 最小栈：用来存储当前栈中最小的值

```java
class MinStack {

    private Stack<Integer> dataStack;
    private Stack<Integer> minNumsStack;
    private int minValue = Integer.MAX_VALUE;

    public MinStack() {
        this.dataStack = new Stack<>();
        this.minNumsStack = new Stack<>();
    }

    public void push(int val) {
        minValue = Math.min(minValue, val);
        minNumsStack.push(minValue);
        dataStack.push(val);
    }

    public void pop() {
        dataStack.pop();
        minNumsStack.pop();
        minValue = minNumsStack.size() == 0 ? Integer.MAX_VALUE : minNumsStack.peek();
    }

    public int top() {
        return dataStack.peek();
    }

    public int getMin() {
        return minNumsStack.peek();
    }
}
```

**优化思路**

* 使用链表实现，每个节点中有值标记为`min`
* 使用尾插法来加入元素

```java
class MinStackI {

    class ListNode {
        int val;
        int min;
        ListNode pre;
        ListNode next;
        ListNode(int val) {
            this.val = val;
        }
        ListNode() {}
    }

    private ListNode head;
    private ListNode tail;

    public MinStackI() {
        head = new ListNode();
        tail = new ListNode();

        head.next = tail;
        tail.pre = head;
        head.min = Integer.MAX_VALUE;
    }

    public void push(int val) {
        ListNode cur = new ListNode(val);
        ListNode pre = tail.pre;
        cur.min = Math.min(val, pre.min);

        // 尾插法
        pre.next = cur;
        cur.pre = pre;

        cur.next = tail;
        tail.pre = cur;
    }

    public void pop() {
        ListNode cur = tail.pre;
        tail.pre = cur.pre;
        cur.pre.next = tail;
    }

    public int top() {
        return tail.pre.val;
    }

    public int getMin() {
        return tail.pre.min;
    }
}
```

## T150 逆波兰表达式求值

**题目描述**

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**我的思路**

* 使用栈来存储操作数，
* 当出现有效的运算符的时候，取出两个操作数，运算
* 将操作数压入栈中

```java
public int evalRPN(String[] tokens) {
    Stack<Integer> dataStack = new Stack<>();
    for (String token : tokens) {
        switch (token) {
            case "+": {
                int num1 = dataStack.pop();
                int num2 = dataStack.pop();
                dataStack.push(num1 + num2);
                break;
            }
            case "-": {
                int num1 = dataStack.pop();
                int num2 = dataStack.pop();
                dataStack.push(num2 - num1);
                break;
            }
            case "*": {
                int num1 = dataStack.pop();
                int num2 = dataStack.pop();
                dataStack.push(num2 * num1);
                break;
            }
            case "/": {
                int num1 = dataStack.pop();
                int num2 = dataStack.pop();
                dataStack.push(num2 / num1);
                break;
            }
            default: {
                dataStack.push(Integer.parseInt(token));
            }
        }
    }
    return dataStack.pop();
}
```

**优化思路**

众所周知，数组是支持随机访问的，实现了`RandomAccess`接口，它的访问速度快很多。如果使用数组来模拟栈，需要知道初始化数组的长度。而对于长度为$2n+1$的波兰表达式，它由$n+1$个操作数和$n$个运算符构成，因此操作数数组的初始化容量为`n`

```java
/**
 * 使用数组模拟栈来解决逆波兰表达式
 * @param tokens
 * @return
 */
public int evalRPNI(String[] tokens) {

    // 特殊情况判断
    if (tokens.length <= 2) return Integer.parseInt(tokens[tokens.length - 1]);

    // 最多有 n / 2 + 1个操作数
    int[] dataStack = new int[tokens.length / 2 + 1];
    int index = 0; // 模拟栈帧
    for (String token : tokens) {
        switch (token) {
            case "+": {
                // 加法，取两位操作数相加，计算结果赋值到第一个操作数中
                dataStack[index - 2] += dataStack[--index]; // 指针左移一位，准备覆盖第二个操作数
                break;
            }
            case "-": {
                dataStack[index - 2] -= dataStack[--index];
                break;
            }
            case "*": {
                dataStack[index - 2] *= dataStack[--index];
                break;
            }
            case "/": {
                dataStack[index - 2] /= dataStack[--index];
                break;
            }
            default: {
                // 操作数，直接入栈
                dataStack[index++] = Integer.parseInt(token);
            }
        }
    }
    return dataStack[0];
}
```

## T224 基本计算器

**题目描述**

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

**我的思路**

* 想办法将其转换为逆波兰表达式
* 然后将逆波兰表达式转换为计算结果

```java
public int calculate(String s) {

    // 将数组转换为逆波兰表达式
    String RPN = transform(s);

    // 将逆波兰表达式转换为计算结果
    return evalRPN(RPN);
}

private int evalRPN(String s) {
    // 特殊情况判断
    String[] rpn = s.split(" ");

    // 最多有 n / 2 + 1个操作数
    int[] dataStack = new int[rpn.length / 2 + 1];
    int index = 0; // 模拟栈帧
    for (String token : rpn) {
        switch (token) {
            case "+": {
                // 加法，取两位操作数相加，计算结果赋值到第一个操作数中
                dataStack[index - 2] += dataStack[--index]; // 指针左移一位，准备覆盖第二个操作数
                break;
            }
            case "-": {
                dataStack[index - 2] -= dataStack[--index];
                break;
            }
            case "*": {
                dataStack[index - 2] *= dataStack[--index];
                break;
            }
            case "/": {
                dataStack[index - 2] /= dataStack[--index];
                break;
            }
            default: {
                // 操作数，直接入栈
                dataStack[index++] = Integer.parseInt(token);
            }
        }
    }
    return dataStack[0];
}

/**
 * 将前缀表达式转换为后缀表达式
 * @param s
 * @return
 */
private String transform(String str) {
    // 去除恶心的空格
    String s = str.replace(" ", "");
    StringBuilder res = new StringBuilder(); // 存储后缀表达式
    Stack<Character> opera = new Stack<>(); // 存储运算符

    for (int i = 0; i < s.length(); i++) {
        char cur = s.charAt(i);


        // 如果当前是操作数，直接添加到结果中
        if (Character.isDigit(cur)) {
            // 处理多位数
            while (i < s.length() && (Character.isDigit(s.charAt(i)))) {
                res.append(s.charAt(i++));
            }
            res.append(' '); // 使用空格分隔
            i--; // 回退
        }
        // 当前是左括号
        else if (cur == '(') {
            // 直接入符号栈
            opera.push(cur);
        }
        // 如果当前是右括号，弹出栈顶直到遇到左括号
        else if (cur == ')') {
            while (!opera.isEmpty() && opera.peek() != '(') {
                res.append(opera.pop()).append(" ");
            }
            // 弹出左括号
            if (!opera.isEmpty() && opera.peek() == '(') {
                opera.pop();
            }
        }

        // 当前是运算符
        else if (isOperator(cur)) {
            // 处理负号，如果负号是第一个字符或者前面的非空字符是括号
            if (cur == '-' ) {
                if (i == 0 || s.charAt(i - 1) == '(') {
                    res.append(0).append(" ");
                }
            }

            // 当前运算符优先级小于等于栈顶
            while (!opera.isEmpty() && getPriority(cur) <= getPriority(opera.peek())) {
                res.append(opera.pop()).append(" ");
            }
            // 将当前压入栈中
            opera.push(cur);
        }
    }

    // 弹出栈中剩余的运算符
    while (!opera.isEmpty()) {
        res.append(opera.pop()).append(' ');
    }
    return res.toString();
}


/**
 * 判断是否为运算符
 * @param c
 * @return
 */
public boolean isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/';
}

private int getPriority(char expressChar) {
    
    if (expressChar == '*' || expressChar == '/') {
        return 1;
    } else if (expressChar == '+' || expressChar == '-'){
        return 0;
    } else {
        return -1;
    }
}
@Test
public void testSolution() {
    String s = "1-(     -2)";
    System.out.println(transform(s));
}
```
