# 数组

## T135 发糖果

**题目**

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**题解**

```java
/**
     * [5, 0, 1, 3, 4]
     * 两次遍历，分别从左遍历，如果 i < i + 1, 设为 1，否则设置为 +1
     * [1, 1, 2, 3, 4]
     * 从右边遍历，判断满足右边的规则需要的糖果
     * [2, 1, 1, 1, 1]
     * 最终为这两个的最大值
     * [2, 1, 2, 3, 4]
     * @param ratings
     * @return
     */
public int candyI(int[] ratings) {
    int n = ratings.length;
    int[] leftRule = new int[n];
    int candy = 0;

    // 遍历满足左规则的时候，需要的最少糖果
    for (int i = 0; i < n; i++) {
        // 当前孩子大于左边孩子，就增加1，否则就只有一颗糖果
        if (i > 0 && ratings[i] - ratings[i - 1] > 0) leftRule[i] = leftRule[i -1] + 1;
        else leftRule[i] = 1;
    }

    int rightRule = 1;
    // 遍历右规则
    for (int i = n - 1; i >= 0; i--) {
        if (i < n - 1 && ratings[i] > ratings[i + 1]) rightRule += 1;
        else rightRule = 1;

        candy += Math.max(leftRule[i], rightRule);
    }

    return candy;
}
```



## T42 接雨水

**题目描述**

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水.

![image-20240817115320232](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/image-20240817115320232.png)

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**题解**

```java 
// 左右双指针
public int trapI(int[] height) {
    int left = 0;
    int right = height.length-1;
    int leftMax = 0;
    int rightMax = 0;
    int water = 0;

    // 如果添加等于，则会造成一个柱子统计两次
    while (left < right) {
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);

        // 当前高度小于左边的最大高度，说明右边可以堵住
        if (height[left] < rightMax) {
            water += leftMax - height[left]; // 左边坝高 - 当前高度
            left++;
        } else {
            // 左边可以堵住
            water += rightMax - height[right]; // 右边坝高 - 当前高度
            right--;
        }
    }
    return water;
}
```

## T13 罗马数字转整数

**题目描述**

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

**题解**

```java
/**
     * 使用SwitchCase判断，当前大于前面的，就做减法
     * @param s
     * @return
     */
public int romanToIntII(String s) {
    int sum = 0;
    int preNum = getValue(s.charAt(0));
    for(int i = 1;i < s.length(); i ++) {
        int num = getValue(s.charAt(i));
        if(preNum < num) {
            sum -= preNum;
        } else {
            sum += preNum;
        }
        preNum = num;
    }
    sum += preNum;
    return sum;
}

private int getValue(char ch) {
    switch(ch) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}
```

## T12 整数转为罗马数字

**题目描述**

将整数转为罗马数字

**题解**

```java
public String intToRoman(int num) {
    String number = String.valueOf(num);
    Stack<String> resStack = new Stack<>();

    // 如何将数拆分为9,5,4,1
    // 3749: 1000 1000 1000 500 100 100 40 9
    int unit = 1;
    for (int i = number.length()-1; i >= 0; i--) {
        int single = (number.charAt(i) - '0');

        StringBuilder tempCode = new StringBuilder();

        // 按照9 5 4 1 对数字进行拆分并将此位罗马数字装进临时编码中
        while (single > 0) {
            if (single - 9 >= 0) {
                single -= 9;
                tempCode.append(getCode(9 * unit));
            }

            if (single - 5 >= 0) {
                single -= 5;
                tempCode.append(getCode(5 * unit));
            }

            if (single - 4 >= 0) {
                single -= 4;
                tempCode.append(getCode(4 * unit));
            }

            if (single - 1 >= 0) {
                single -= 1;
                tempCode.append(getCode(1 * unit));
            }
        }
        
        // 将此位的罗马数字压到栈中
        resStack.push(tempCode.toString());
        unit *= 10;

    }

    StringBuilder res = new StringBuilder();

    while(resStack.size() > 0) {
        res.append(resStack.pop());
    }

    return res.toString();

}

public String getCode(Integer number) {
    switch (number) {
        case 1: return "I";
        case 4: return "IV";
        case 5: return "V";
        case 9: return "IX";
        case 10: return "X";
        case 40: return "XL";
        case 50: return "L";
        case 90: return "XC";
        case 100: return "C";
        case 400: return "CD";
        case 500: return "D";
        case 900: return "CM";
        case 1000: return "M";
    }
    return "";

}
```



## T58 最后一个单词长度

**题目**

给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。

**示例 1：**

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为 5。
```

**题解**

```java
public int lengthOfLastWordI(String s) {

    int res = 0;
    // 倒序遍历
    for (int i = s.length() - 1; i >= 0; i--) {
        // 去掉尾部的空格
        if (s.charAt(i) == ' ' && res == 0) continue;
        if (s.charAt(i) == ' ') break;
        else res++;
    }

    return res;

}
```





## T14 公共最长前缀

**题目描述**

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**题解**

```java
public String longestCommonPrefix(String[] strs) {

        if (strs.length == 0) return "";
        if (strs.length == 1) return strs[0];

        StringBuilder prefix = new StringBuilder();

        for (int i = 0; i <= strs[0].length()-1; i++) {
            if (isSameChar(strs, i)) {
                prefix.append(strs[1].charAt(i));
            } else {
                break;
            }
        }
        return prefix.toString();

    }

    public boolean isSameChar(String[] strs, int index) {
        boolean flag = true;
        for (int i = 1; i < strs.length; i++) {
            // 下标边界判断
            if (index < strs[i].length() && strs[i].charAt(index) == strs[0].charAt(index)) continue;
            else {
                flag = false;
                break;
            }
        }
        return flag;
    }
```

## T151 反转字符串中的单词

**题目描述**

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**题解**

```java
public String reverseWords(String s) {
    String trimS = s.trim(); // 字符串瘦身
    String[] words = trimS.split(" "); // 空格拆分
    StringBuilder res = new StringBuilder(); 
    for (int i = words.length - 1; i >= 0; i--) {
        // 中间有连续空格就会造成有空串出现，需要判断
        if (!"".equals(words[i])) res.append(words[i]).append(" ");
    }
    return res.toString().trim();
}
```

## T6 Z字变换

**题目描述**

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

**题解**

```java
/**
* 首先确定V字的元素个数
* 其次是确定二维数组列数
* 垂直指针v，水平指针h
* 判断 当前总元素数 % V字元素数 < 行数 &&  当前总元素数 % V字元素数 ！= 0 V 向下; 反之v向上，h向右;
*
*/
public String convert(String s, int numRows) {
    if (numRows <= 1) return s;
    int elements = (2*numRows-2); // 一个V字的元素数
    int batch = s.length() / elements; // 有几组完整的V字
    int remainders = s.length() % elements; // 计算有多少列
    int col = batch * (numRows - 1);
    col += remainders <= numRows ? 1 : remainders - numRows + 1;

    char[][] map = new char[numRows][col];
    int v = 0; int h = 0;
    for (int i = 0; i < s.length(); i++) {
        map[v][h] = s.charAt(i);
        if ((i+1) % elements < numRows && (i+1) % elements != 0) { // 垂直指针往下走，水平不动
            v++;
        } else { // 垂直指针往上走，水平往右边走
            v--;
            h++;
        }
    }
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < col; j++) {
            if (map[i][j] != 0) {
                builder.append(map[i][j]);
            }
        }
    }
    return  builder.toString();

}



/**
* 使用curRow 和 boolean down 来控制方向
* 
*/
public String convert(String s, int numRows) {
    if (numRows <= 1) return s;
    // 首先确定总共有几行, 每一行作为一个StringBuffer加入入到集合中
    List<StringBuilder> rows = new ArrayList<StringBuilder>();
    for (int i = 0; i < Math.min(s.length(), numRows); i++) {
        rows.add(new StringBuilder());
    }

    int curRow = 0;
    boolean down = false;
    for (char c : s.toCharArray()) {
        rows.get(curRow).append(c);
        if (curRow == 0 || curRow == numRows - 1) { // 第一行和最后一行都需要改变方向
            down = !down;
        }
        curRow += down ? 1 : -1;
    }

    StringBuffer result = new StringBuffer();
    for (StringBuilder row : rows) {
        result.append(row);
    }
    return result.toString();

}

```

## T68 文本左右对齐

**题目描述**

给定一个单词数组 `words` 和一个长度 `maxWidth` ，重新排版单词，使其成为每行恰好有 `maxWidth` 个字符，且左右两端对齐的文本。

**示例 2:**

```
输入:words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
输出:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
```

**题解**

```java 
public List<String> fullJustify(String[] words, int maxWidth) {

        List<String> res = new ArrayList<>();

        int len = 0;
        List<String> rowWords = new ArrayList<>();
        for (int i = 0; i < words.length; i++) {
            if (len + words[i].length() <= maxWidth) {
                rowWords.add(words[i] + " ");
                len += words[i].length() + 1; // 每个单词要加一个空格
            } else {
                String rowString = getRowString(len, rowWords, maxWidth, false);
                res.add(rowString);
                len = 0;
                rowWords.clear();
                i--;
            }
        }
        // 对最后一行的处理
        res.add(getRowString(len, rowWords, maxWidth, true));
        return res;
    }


    public String getRowString(int len, List<String> rowWords, int maxWidth, boolean last) {
        // 此时单词应当是 This |is |an |
        len -= 1; // 用掉的长度为这么多
        int gaps = rowWords.size() - 1 == 0 ? 1 : rowWords.size() - 1; // 间隙
        int remainBlanks = maxWidth - len;
        StringBuilder blank = new StringBuilder();
        if (last) {
            // 最后一行左对齐
            for (int i = 0; i < remainBlanks; i++) {
                blank.append(" ");
            }
            rowWords.set(rowWords.size()-1, rowWords.get(rowWords.size()-1) + blank);
        } else {
            int blanks = remainBlanks / gaps; // 平均每个间隙插的空格数

            for (int j = 0; j < blanks; j++) {
                blank.append(" ");
            }
            int remainders = remainBlanks % gaps; // 剩多少个空格
            for (int j = 0; j < remainders; j++) {
                rowWords.set(j, rowWords.get(j) + " "); // 多出来的空格添加到左边
            }
            // 给每个单词添加空格
            for (int j = 0; j < gaps; j++) {
                rowWords.set(j, rowWords.get(j) + blank.toString());
            }
        }

        // 将单词拼接起来
        StringBuilder wordText = new StringBuilder();
        for (String word : rowWords) {
            wordText.append(word);
        }
        return wordText.substring(0, wordText.length() - 1);
    }
```

# 双指针

## T125 验证回文串

**题目描述**

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**题解**

```java
public boolean isPalindrome(String s) {
    // 去重，移出所有的非小写字母字符
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if ((c >= 'a' && c <= 'z') || (c + 32 >= 'a' && c + 32 <= 'z') || (c >= '0' && c <= '9')) {
            if ((c + 32 >= 'a' && c + 32 <= 'z')) {
                builder.append((char)(c + 32));
            } else {
                builder.append(c);
            }
        }
    }
    String trimString = builder.toString();
    int i = 0; int j = trimString.length() - 1;
    while (i < j) {
        if (trimString.charAt(i) == trimString.charAt(j)) {
            i++; j--;
        } else {
            return false;
        }
    }
    return true;
}

Character.isLetterOrDigit(). // 判断是否是数字或者是字母
```

## T392 判断子序列

**题目描述**

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**题解**

```java
/**
* 双指针
* /
public boolean isSubsequence(String s, String t) {

    int i = 0; int j = 0;
    while (i < s.length() && j < t.length()) {
        while (j < t.length() && s.charAt(i) != t.charAt(j)) {
            j++;
        }
        while (i < s.length() && j < t.length() && s.charAt(i) == t.charAt(j)) {
            i++; j++;
        }
    }
    return i >= s.length();
}


/**
     * 动态规划，f[i][j]表示从索引 i 开始 第 j 个小写字母出现的位置索引
     * @param s
     * @param t
     * @return
     */
public boolean isSubsequenceII(String s, String t) {
    int n = s.length(), m = t.length();

    int[][] f = new int[m + 1][26];
    for (int i = 0; i < 26; i++) {
        f[m][i] = m; // 如果出现m表示没有出现过该字母
    }

    for (int i = m - 1; i >= 0; i--) {
        for (int j = 0; j < 26; j++) {
            if (t.charAt(i) == j + 'a')
                f[i][j] = i; // 索引 i 开始后的 j 字母出现的第一个位置委 i
            else
                f[i][j] = f[i + 1][j];
        }
    }
    int add = 0;
    for (int i = 0; i < n; i++) {
        if (f[add][s.charAt(i) - 'a'] == m) {
            return false;
        }
        add = f[add][s.charAt(i) - 'a'] + 1;
    }
    return true;
}
```

## T167 两数之和II-输入为有序数组

**题目描述**

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**题解**

```java
/**
* 双指针
*
*/
public int[] twoSum(int[] numbers, int target) {
    int i = 0, j = numbers.length - 1;
    int[] res = new int[2];
    while (i < j) {
        if (numbers[i] + numbers[j] == target) {
            break;
        } else if (numbers[i] + numbers[j] > target) {
            j--;
        } else {
            i++;
        }
    }
    res[0] = i + 1;
    res[1] = j + 1;
    return res;
}

```

## T15 三数之和

**题目描述**

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**题解**

```java
/**
     * beats 5%
     * 主要思路：
     * 1.排序
     * 2.定住一个数 i
     * 3.双指针i+1 length-1，往中间遍历，符合条件加入到Map中，去重
     * 4.返回
     * @param nums
     * @return
     */
public List<List<Integer>> threeSum(int[] nums) {

    List<List<Integer>> resList = new ArrayList<>();
    Map<String, List<Integer>> distinctMap = new HashMap<>();
    // 从左到右固定一个，然后双指针
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 2; i++) {
        int j = i + 1;
        int k = nums.length - 1;

        while (j < k) {
            if (nums[i] + nums[j] + nums[k] == 0) {
                List<Integer> res = new ArrayList<>();
                res.add(nums[i]);
                res.add(nums[j]);
                res.add(nums[k]);
                String key = nums[i] + "" + nums[j] + nums[k];
                distinctMap.putIfAbsent(key, res);
                j++;
                k--;
            } else if (nums[i] + nums[j] + nums[k] < 0) {
                j++;
            } else {
                k--;
            }
        }
    }
    // 对Map遍历
    for (Map.Entry<String, List<Integer>> res : distinctMap.entrySet()) {
        resList.add(res.getValue());
    }

    return resList;
}
```

可以优化的点：

* 如果第一个数就大于0，直接返回，`if nums[i] >0 break;`
* 如果最后一个数小于0，直接返回，`if nums[j] < 0 beak;`
* 去重操作怎么弄？就是如果下一个数还是等于当前的数，就直接跳过

# 滑动窗

## T209 长度最小的子数组

**题目描述**

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 

**子数组**

`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

> 一定要注意不能打乱元素的顺序

**题解**

```
/**
 * 根据题目要求应该是不能排序的、
 * 使用双指针，维护一个动态长度的窗口
 * @param target
 * @param nums
 * @return
 */
public int minSubArrayLenI(int target, int[] nums) {

    // 特殊情况
    if (nums.length  == 1) {
        return target <= nums[0] ? 1 : 0;
    }

    int curSum = nums[0];
    int minLen = Integer.MAX_VALUE;
    int i = 0; int j = 0;
    while (j < nums.length) {
        if (curSum >= target) {
            minLen = Math.min(minLen, j - i + 1);
            curSum -= nums[i++]; // 左边界内收
        } else {
            if (++j < nums.length) {
                curSum += nums[j];
            }
        }
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;

}
```

## T3 无重复字符串的最长字串

**题目描述**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串**的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**题解**

```java
/**
 * 使用双指针的方法
 * 主要思想：
 * 快慢指针，快指针添加元素，慢指针删除重复的元素
 * 元素保存在Hash表中，一定要记得将 i 和 重复元素 之间的所有元素删除
 * @param s
 * @return
 */
public int lengthOfLongestSubstring(String s) {
    int maxLen = 0;
    if (s.length() <= 1) return s.length();
    int i = 0; int j = 0;
    Map<Character ,Integer> dictMap = new HashMap<>();
    while (true) {

        while (j < s.length() &&  !dictMap.containsKey(s.charAt(j))) {
            dictMap.put(s.charAt(j), j++);
        }

        // 说明已经出现了重复的情况，或者是到头的情况
        maxLen = Math.max(maxLen, j - i);
        if (j == s.length()) return maxLen;

        // 清除掉HashMap中重复的元素
        int nextJump = dictMap.get(s.charAt(j));
        while (i <= nextJump) {
            dictMap.remove(s.charAt(i++));
        }
        dictMap.put(s.charAt(j), j++);
    }
}
```

## T30 串联所有的单词子串

**题目描述**

给定一个字符串 `s` 和一个字符串数组 `words`**。** `words` 中所有字符串 **长度相同**。

 `s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

**示例 1：**

```
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
```

**题解**

```java
public List<Integer> findSubstringI(String s, String[] words) {	
	List<Integer> res = new ArrayList<>();
    // 所有单词的个数
    int num = words.length;
    // 每个单词的长度（是相同的）
    int wordLen = words[0].length();
    // 字符串长度
    int stringLen = s.length();

    for (int i = 0; i < wordLen; i++) {
        // 遍历的长度超过了整个字符串的长度，退出循环
        if (i + num * wordLen > stringLen) {
            break;
        }
        // differ表示窗口中的单词频次和words中的单词频次之差
        Map<String, Integer> differ = new HashMap<>();
        // 初始化窗口，窗口长度为num * wordLen,依次计算窗口里每个切分的单词的频次
        for (int j = 0; j < num; j++) {
            String word = s.substring(i + j * wordLen, i + (j + 1) * wordLen);
            differ.put(word, differ.getOrDefault(word, 0) + 1);
        }
        // 遍历words中的word，对窗口里每个单词计算差值
        for (String word : words) {
            differ.put(word, differ.getOrDefault(word, 0) - 1);
            // 差值为0时，移除掉这个word
            if (differ.get(word) == 0) {
                differ.remove(word);
            }
        }
        // 开始滑动窗口
        for (int start = i; start < stringLen - num * wordLen + 1; start += wordLen) {
            if (start != i) {
                // 右边的单词滑进来
                String word = s.substring(start + (num - 1) * wordLen, start + num * wordLen);
                differ.put(word, differ.getOrDefault(word, 0) + 1);
                if (differ.get(word) == 0) {
                    differ.remove(word);
                }
                // 左边的单词滑出去
                word = s.substring(start - wordLen, start);
                differ.put(word, differ.getOrDefault(word, 0) - 1);
                if (differ.get(word) == 0) {
                    differ.remove(word);
                }
                word = s.substring(start - wordLen, start);
            }
            // 窗口匹配的单词数等于words中对应的单词数
            if (differ.isEmpty()) {
                res.add(start);
            }
        }
    }
    return res;
}
```

## T76 最小覆盖字串

**题目描述**

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

 **题解**

* 定义两个数组来记录词频
* 每当有新字符添加到母串的词频数组中，就判断是否涵盖
* 涵盖的话就`trim`字符串

```java
public String minWindow(String S, String t) {
    char[] s = S.toCharArray();
    int m = s.length;
    int ansLeft = -1;
    int ansRight = m;
    int left = 0;
    int[] cntS = new int[128]; // s 子串字母的出现次数
    int[] cntT = new int[128]; // t 中字母的出现次数
    for (char c : t.toCharArray()) {
        cntT[c]++;
    }
    for (int right = 0; right < m; right++) { // 移动子串右端点
        cntS[s[right]]++; // 右端点字母移入子串
        while (isCovered(cntS, cntT)) { // 涵盖
            if (right - left < ansRight - ansLeft) { // 找到更短的子串
                ansLeft = left; // 记录此时的左右端点
                ansRight = right;
            }
            cntS[s[left++]]--; // 左端点字母移出子串
        }
    }
    return ansLeft < 0 ? "" : S.substring(ansLeft, ansRight + 1);
}


/**
 * 如何判断涵盖呢？
 * 遍历，频次大于等于字串
 * @param cntS
 * @param cntT
 * @return
 */
private boolean isCovered(int[] cntS, int[] cntT) {
    for (int i = 'A'; i <= 'Z'; i++) {
        if (cntS[i] < cntT[i]) {
            return false;
        }
    }
    for (int i = 'a'; i <= 'z'; i++) {
        if (cntS[i] < cntT[i]) {
            return false;
        }
    }
    return true;
}
```

# 矩阵

## T36 有效的数独

**题目描述**

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

**解答**

* 先判断每一行是否满足规则
* 判断每一列是否满足规则
* 判断每个小方块是否满足规则

```java 
/**
     * 每行每列
     * @param board
     * @return
     */
public boolean isValidSudoku(char[][] board) {
    // 首先判断每行是否符合
    for (int i = 0; i < board.length; i++) {
        int[] isVisited = new int[10];
        for (int j = 0; j < board[i].length; j++) {
            if (board[i][j] != '.') {
                if (isVisited[board[i][j]- '0']  != 1) {
                    isVisited[board[i][j]- '0'] = 1;
                } else {
                    return false;
                }
            }
        }
    }

    // 判断每列是否符合
    for (int i = 0; i < board[0].length; i++) {
        int[] isVisited = new int[10];
        for (int j = 0; j < board.length; j++) {
            if (board[j][i] != '.') {
                if (isVisited[board[j][i] - '0'] != 1) {
                    isVisited[board[j][i] - '0'] = 1;
                } else {
                    return false;
                }
            }
        }
    }

    // 判断每个小方格是否符合
    for (int i = 2; i < board.length; i += 3) {
        for (int j = 2; j < board[0].length; j += 3) {
            int[] isVisited = new int[10];
            for (int k = i - 2; k <= i; k++) {
                for (int l = j - 2; l <= j; l++) {
                    if (board[k][l] != '.') {
                        if (isVisited[board[k][l] - '0'] != 1) {
                            isVisited[board[k][l] - '0'] = 1;
                        } else {
                            return false;
                        }
                    }
                }
            }
        }
    }

    return true;
}
```

## T54 螺旋矩阵

**题目描述**

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**思路**

* 四个方向`diretion`，`right->down->left->up`
* 四个边界，然后使用递归调用

```java
public List<Integer> spiralOrder(int[][] matrix) {


    // 0 左 1 下 2 右 3 上
    int direction = 0;
    List<Integer> res = new ArrayList<>();
    // 边界
    int[] border = new int[4];
    border[0] = matrix[0].length-1; // 右边界
    border[1] = matrix.length-1; // 下边界
    border[2] = 0; // 上边界
    border[3] = 0; // 左边界

    rotateMatrix(matrix, direction, res, border);
    return res;
}

private void rotateMatrix(int[][] matrix, int direction, List<Integer> res, int[] border) {
    if (res.size() == matrix.length * matrix[0].length) return;
    switch (direction) {
        case 0:
            // 从左到右,固定上边界，上边界减1
            for (int k = border[3]; k <= border[0]; k++) {
                res.add(matrix[border[2]][k]);
            }
            // 上边界加1
            border[2]++;
            // 向下打印
            rotateMatrix(matrix, 1, res, border);
            break;
        case 1:
            // 从上到下,右边界固定，右边界减1
            for (int k = border[2]; k <= border[1]; k++) {
                res.add(matrix[k][border[0]]);
            }
            border[0]--;
            // 向左打印
            rotateMatrix(matrix, 2, res, border);
            break;
        case 2:
            // 从右往左打印，固定下边界，下边界减1
            for (int i = border[0]; i >= border[3]; i--) {
                res.add(matrix[border[1]][i]);
            }
            border[1]--;
            rotateMatrix(matrix, 3, res, border);
            break;
        case 3:
            for (int i = border[1]; i >= border[2]; i--) {
                res.add(matrix[i][border[3]]);
            }
            border[3]++;
            rotateMatrix(matrix, 0, res, border);
    }
}
```

## T48 旋转图像

**题目描述**

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**题解**

* 从右下角开始读取元素，一圈到数组中，每一圈有4$N$个元素
* 从数组开始读取元素，写到原来的矩阵中

![image-20240914175918447](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/image-20240914175918447.png)

观察翻转前后的图，我们可以看出，主要是进行了以下的操作：

* 将矩阵转置

* 交换每一行的首尾元素

```java
public void rotateI(int[][] matrix) {
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < i; j++) {
            // 交换matrix[i][j]和matrix[j][i]
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // 对每一行进行反转
    for (int i = 0; i < matrix.length; i++) {
        int l = 0; int r = matrix[i].length - 1;
        while (l < r) {
            int temp = matrix[i][l];
            matrix[i][l] = matrix[i][r];
            matrix[i][r] = temp;

            l++;
            r--;
        }
    }

    System.out.println("=========after===========");
    for (int i = 0; i < matrix.length; i++) {
        System.out.println(Arrays.toString(matrix[i]));
    }
}
```

## T73 矩阵置零

**题目描述**

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

**题解**

```java
/**
     * 实现思路：先遍历一遍，将行和列分别存储在两个set中
     * 再遍历一遍，如果当前坐标在set中，就置为0
     * @param matrix
     */
public void setZeroes(int[][] matrix) {
    Set<Integer> rowSet = new HashSet<>();
    Set<Integer> colSet = new HashSet<>();

    // 将 0 元素的行列存储到对应的 set 中
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) {
            if (matrix[i][j] == 0) {
                rowSet.add(i);
                colSet.add(j);
            }
        }
    }

    // set 中的行或者列都置为 0
    for (int i = 0; i < matrix.length; i++) {
        if (rowSet.contains(i)) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = 0;
            }
        } else {
            for (int j = 0; j < matrix[i].length; j++) {
                if (colSet.contains(j)) {
                    matrix[i][j] = 0;
                }
            }
        }
    }


    System.out.println("=========transformed matrix==========");
    for (int i = 0; i < matrix.length; i++) {
        System.out.println(Arrays.toString(matrix[i]));
    }
}
```

**优化方法**

使用空间为$o(1)$实现代码

* 第一行作为标记行，记录出现0的列
* 第一列作为标记列，记录出现0的行
* 额外两个变量，分别记录第一列和第一行是否为0
* 将含0的行和含0的列置为0
* 对第一行进行处理

## T289 生命游戏

**题目描述**

给定一个包含 `m × n` 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： `1` 即为 **活细胞** （live），或 `0` 即为 **死细胞** （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 `m x n` 网格面板 `board` 的当前状态，返回下一个状态。

**题解**

```java
/**
 * 1.定义一个统计周围活细胞的方法
 * 2.根据条件确定该细胞是否存活
 * @param board
 */
public void gameOfLife(int[][] board) {

    int[][] aliveCells = new int[board.length][board[0].length];

    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[i].length; j++) {
            // 当前细胞死活
            int counts = countAliveCells(i, j, board);
            if (board[i][j] == 1) {
                if (counts < 2) {
                    aliveCells[i][j] = 0;
                } else if (counts <= 3) {
                    aliveCells[i][j] = 1;
                } else {
                    aliveCells[i][j] = 0;
                }
            } else {
                // 当前细胞死了
                if (counts == 3) {
                    aliveCells[i][j] = 1;
                } else {
                    aliveCells[i][j] = 0;
                }
            }
        }
    }


    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            board[i][j] = aliveCells[i][j];
        }
    }


    System.out.println("===========next status============");
    for (int[] rows : aliveCells) {
        System.out.println(Arrays.toString(rows));;
    }

}

private int countAliveCells(int i, int j, int[][] board) {
    int beginRow = Math.max(i - 1, 0);
    int endRow = Math.min(i + 1, board.length - 1);
    int beginCol = Math.max(j - 1, 0);
    int endCol = Math.min(j + 1, board[0].length - 1);

    int count = 0;
    for (int k = beginRow; k <= endRow; k++) {
        for (int l = beginCol; l <= endCol; l++) {
            if (board[k][l] == 1 && (k != i || l != j)) {
                count++;
            }
        }
    }

    return count;
}
```

**优化思路**

* 细胞具体可以分为4种状态
  * 当前死，下一秒死：`00`
  * 当前死，下一秒活：`10`
  * 当前活，下一秒死：`01`
  * 当前活，下一秒活：`11`

* 获取当前状态的方法：`board[i][j] & 1`
* 获取下一秒状态的方法：`board[i][j] >> 1`

# 哈希表

## T383 赎金信

**题目描述**

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**题解**

```java
/**
 * 将 magazine中的字符和出现频次统计在HashMap中
 * 遍历 ransomNote，如果出现，就减1
 * @param ransomNote
 * @param magazine
 * @return
 */
public boolean canConstruct(String ransomNote, String magazine) {
    Map<Character, Integer> charMap = new HashMap<>();
    // 将magazine中的字符统计在HashMap
    for (char c : magazine.toCharArray()) {
        if (charMap.containsKey(c)) {
            charMap.put(c, charMap.get(c) + 1);
        } else {
            charMap.put(c, 1);
        }
    }

    for (char c : ransomNote.toCharArray()) {
        if (!charMap.containsKey(c)) {
            return false;
        } else {
            int counts = charMap.get(c);
            if (counts == 1) {
                charMap.remove(c, counts);
            } else {
                charMap.put(c, counts - 1);
            }
        }
    }
    return true;
}
```

**优化方法**

题目中给出，两者全部由小写字母给出，可以使用1个定长数组进行统计`magazine`数组出现的字符。如果`magazine`包含`ransomNote`就可以。

具体来说就是遍历`ransomNote`的时候对`magazine`统计数组操作

**优化方法二**

`int[] res`记录当前字符在数组中出现的位置的下一位的坐标，使用`indexOf`确定是否含有当前字符

## T205 同构字符串

**题目描述**

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**题解**

```java
/**
 * 分别将 s对t的映射和t对s的映射存储到两个Map中
 * @param s
 * @param t
 * @return
 */
public boolean isIsomorphic(String s, String t) {
    Map<Character, Character> s2t = new HashMap<>();
    Map<Character, Character> t2s = new HashMap<>();

    for (int i = 0; i < s.length(); i++) {
        char x = s.charAt(i);
        char y = t.charAt(i);
        if (s2t.containsKey(x) && s2t.get(x) != y || t2s.containsKey(y) && t2s.get(y) != x) {
            return false;
        }
        s2t.put(x, y);
        t2s.put(y, x);
    }
    return true;
}
```

## T290 单词规律

**题目描述**

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

```
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
```

**题解**

> 和T205相同的做法

```java
/**
 * 将字符串拆分为数组
 * @param pattern
 * @param s
 * @return
 */
public boolean wordPattern(String pattern, String s) {
    String[] array = s.split(" ");
    char[] chars = pattern.toCharArray();
    if (chars.length != array.length) return false;
    Map<Character, String> c2s =  new HashMap<>();
    Map<String, Character> s2c = new HashMap<>();
    for (int i = 0; i < array.length; i++) {
        if (c2s.containsKey(chars[i]) && !c2s.get(chars[i]).equals(array[i]) ||
                s2c.containsKey(array[i]) && !s2c.get(array[i]).equals(chars[i])) {
            return false;
        }
        c2s.put(chars[i], array[i]);
        s2c.put(array[i], chars[i]);
    }
    return true;

}
```

## T242 有效的字母异位词

**题目描述**

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的 字母异位词

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**题解**

* 字符串仅仅包含小写字符，可以使用两个数组统计词频
* 判断词频是否相同

```java
public boolean isAnagram(String s, String t) {
    int[] codeBook = new int[26];
    Arrays.fill(codeBook, 0);
    for (char c : s.toCharArray()) {
        codeBook[c - 'a'] ++;
    }
    for (char c : t.toCharArray()) {
        if (codeBook[c - 'a'] == 0) {
            return false;
        }
        codeBook[c - 'a']-- ;
    }

    // 检查codeBook是否为0
    for (int i : codeBook) {
        if (i != 0) {
            return false;
        }
    }
    return true;
}
```

## T49 字母异位词分组

**题目描述**

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**思路**

* `Map<String, Integer> codeBook`用来比较词频，其中`String`表示压缩编码，而`Integer`表示结果集中的索引
* `List<List<String>>`存放返回结果
* 遍历字符串数组，如果词频数组相同，就根据词频数组的索引加入到相应索引中
  * 否则添加到新的数组中，并加入到词频`Map`中

**题解**

```java
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> resList = new ArrayList<>();
    Map<String, Integer> codeBook = new HashMap<>();

    for (String str : strs) {
        String compressedCode = getCharCounts(str);
        if (codeBook.containsKey(compressedCode)) {
            int i = codeBook.get(compressedCode);
            resList.get(i).add(str);
        } else {
            List<String> strList = new ArrayList<>();
            strList.add(str);
            resList.add(strList);
            int i = resList.lastIndexOf(strList);
            codeBook.put(compressedCode, i);
        }
    }

    return resList;
}


/**
 * 统计单词每个字符出现的词频，并进行压缩返回
 * @param str
 * @return
 */
private String getCharCounts(String str) {

    int[] array = new int[26]; // 记录词频的数组
    Arrays.fill(array, 0);

    for (char c : str.toCharArray()) {
        array[c - 'a']++;
    }

    // 将词频转换为压缩字符串
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < array.length; i++) {
        if (array[i] != 0) {
            sb.append(i + 'a').append(array[i]);
        }
    }
    return sb.toString();
}
```

## T1 两数之和

**题目描述**

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

**题解**

* 如果余数`target - nums[i]`匹配失败，才会让`nums[i]`入库，防止和自己重复匹配

```java
/**
 * map存放和target - nums[i]匹配失败的数字
 * @param nums
 * @param target
 * @return
 */
public int[] twoSum(int[] nums, int target) {
    // 如果出现重复的数字，那么只会重复一次，并且答案就是重复的两个数字
    Map<Integer, Integer> map = new HashMap<>();
    int[] res = new int[2];
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(target - nums[i])) {
            res[0] = i;
            res[1] = map.get(target - nums[i]);
            return  res;
        } else {
            map.put(nums[i], i);
        }
    }
    return null;
}
```

## T202 快乐数

**题目描述**

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**思路**

* 按位取平方和，判断是否为1
* 平方和为1直接返回
* 平方和不为1存到`set`中
* 如果和存在，则返回`false`

```java
public boolean isHappy(int n) {
    Set<Integer> sumSet = new HashSet<>();
    while (true) {
        n = squareSum(n);
        if (n == 1) return true;
        else {
            if (sumSet.contains(n)) return false;
            else sumSet.add(n);
        }
    }
}

private int squareSum(int n) {
    int res = 0;
    String numStr = String.valueOf(n);
    for (char c : numStr.toCharArray()) {
        res += Math.pow(c - '0', 2.0);
    }
    return res;
}
```

**优化**

> 注意到，平方和作为一个链表中的一个节点出现，如果出现死循环，一定是链表中出现了环，就变成如何判断链表中是否出现环了

因此可以使用快慢指针，快指针一次操作两次，慢指针一次操作1次。判断相遇的时候是否为节点1

```java
/**
* 使用快慢指针实现
* @param n
* @return
*/
public boolean isHappyI(int n) {
    int slow = squareSum(n);
    int fast = squareSum(slow);
    while (slow != fast) {
        slow = squareSum(slow);
        fast = squareSum(fast);
        fast = squareSum(fast);
    }
    return slow == 1;
}
```

## T219 存在重复元素II

**题目描述**

给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

**思路**

* 定义一个`Map<Integer, Integer>`存储数字和坐标
* 如果当前数字`nums[i]`不存在，则直接入库
* 如果存在，则比较`map`中坐标`j`和当前坐标`i`的距离是否大于`k`，是的话直接返回`true`
* 距离小于`k`则不入库

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(nums[i])) {
            if (i - map.get(nums[i]) <= k) {
                return true;
            }
        }
        map.put(nums[i], i);

    }
    return false;
}
```

## T128 最长连续序列

**题目描述**

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**思路**

* 首先将数组去重

* 将数组排序
* 双指针判断是否连续，如果连续则当前长度`curLen++`
* 不连续当前长度置零`curLen = 0`
* 判断当前长度和最大长度的大小`maxLen = Math.max(curLen, maxLen)`

```java
public int longestConsecutive(int[] nums) {
    int maxLen = 1;
    if (nums.length <= 1) return nums.length;
    // nums中可能有重复的，需要去重操作
    Set<Integer> numSet = new HashSet<>();
    for (int i : nums) {
        numSet.add(i);
    }
    List<Integer> distinctList = new ArrayList<>(numSet);
    int[] distinctNums = new int[distinctList.size()];
    for (int i = 0; i < distinctNums.length; i++) {
        distinctNums[i] = distinctList.get(i);
    }
    Arrays.sort(distinctNums);

    int i = 0; int j = 1;
    while (j < distinctNums.length) {
        while (j < distinctNums.length && distinctNums[j] - distinctNums[j - 1] == 1) {
            j++;
        }
        maxLen = Math.max(j - i, maxLen);
        i = j++; // 新序列的第一个位置和第二个位置
    }


    return maxLen;


}
```

**优化思路**

> 题目给出的是使用$O(n)$的计算复杂度，所以就不能使用排序的方式了。

* 考虑将所有的元素存储到一个`Set<Integer> numSet`集合中
* 如果集合中不存在`num[i]-1`元素，就以当前元素为序列起始点
* 循环判断集合中是否存在`num[i] + 1`元素
* 记录最长的长度

```java
/**
 * 使用 o(n)的算法优化
 * @param nums
 * @return
 */
public int longestConsecutiveI(int[] nums) {


    if (nums.length <= 1) return nums.length;
    Set<Integer> numSet = new HashSet<>();
    for (int j : nums) {
        numSet.add(j);
    }
    int maxLen = 1;

    for (int num : nums) {

        // 当前值为序列头
        if (!numSet.contains(num - 1)) {
            int nextNum = num + 1;
            int curLen = 1;
            // 下一个值能够续上
            while (numSet.contains(nextNum)) {
                curLen++;
                nextNum++;
            }
            maxLen = Math.max(curLen, maxLen);
        }
    }
    return maxLen;
}
```
